<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>力扣刷题记录</title>
    <url>/2022/07/05/002-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><h3 id="关于力扣上的代码如何在本地编译运行"><a href="#关于力扣上的代码如何在本地编译运行" class="headerlink" title="关于力扣上的代码如何在本地编译运行"></a>关于力扣上的代码如何在本地编译运行</h3><p>定义个main函数，构造个输入用例，然后定义一个solution变量，调用函数就可以了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; cost.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[cost.<span class="built_in">size</span>() - <span class="number">1</span>], dp[cost.<span class="built_in">size</span>() - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cost</span><span class="params">(a, a + <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line">    Solution solution;</span><br><span class="line">    cout &lt;&lt; solution.<span class="built_in">minCostClimbingStairs</span>(cost) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第300场周赛补题-蔚来"><a href="#第300场周赛补题-蔚来" class="headerlink" title="第300场周赛补题-蔚来"></a>第300场周赛补题-蔚来</h2><h3 id="2325-解密消息（简单）"><a href="#2325-解密消息（简单）" class="headerlink" title="2325. 解密消息（简单）"></a>2325. 解密消息（简单）</h3><p>给你字符串 key 和 message ，分别表示一个加密密钥和一段加密消息。解密 message 的步骤如下：</p>
<p>使用 key 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 顺序 。<br>将替换表与普通英文字母表对齐，形成对照表。<br>按照对照表 替换 message 中的每个字母。<br>空格 ‘ ‘ 保持不变。<br>例如，key = “happy boy”（实际的加密密钥会包含字母表中每个字母 至少一次），据此，可以得到部分对照表（’h’ -&gt; ‘a’、’a’ -&gt; ‘b’、’p’ -&gt; ‘c’、’y’ -&gt; ‘d’、’b’ -&gt; ‘e’、’o’ -&gt; ‘f’）。</p>
<p>题目链接：<a href="https://leetcode.cn/problems/decode-the-message">https://leetcode.cn/problems/decode-the-message</a></p>
<p><strong>示例</strong></p>
<img src="/2022/07/05/002-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2325.jpg" class title="This is an test image">
<blockquote>
<p>输入：key = “the quick brown fox jumps over the lazy dog”, message = “vkbs bs t suepuv”<br>输出：”this is a secret”<br>解释：对照表如上图所示。<br>提取 “the quick brown fox jumps over the lazy dog” 中每个字母的首次出现可以得到替换表。</p>
</blockquote>
<p>对map之类的容器生疏了，比赛的时候写的太复杂了，这里复习一遍用法加强印象<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeMessage</span><span class="params">(string key, string message)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>,<span class="type">char</span>&gt; mp;</span><br><span class="line">        mp[<span class="string">&#x27; &#x27;</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;key.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp[key[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                mp[key[i]] = <span class="string">&#x27;a&#x27;</span> + cnt;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;message.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            message[i] = mp[message[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="2326-螺旋矩阵-IV（中等）"><a href="#2326-螺旋矩阵-IV（中等）" class="headerlink" title="2326. 螺旋矩阵 IV（中等）"></a>2326. 螺旋矩阵 IV（中等）</h3><p>给你两个整数：m 和 n ，表示矩阵的维数。</p>
<p>另给你一个整数链表的头节点 head 。</p>
<p>请你生成一个大小为 m x n 的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵 左上角 开始、顺时针 按 螺旋 顺序填充。如果还存在剩余的空格，则用 -1 填充。</p>
<p>返回生成的矩阵。</p>
<p>题目链接：<a href="https://leetcode.cn/problems/spiral-matrix-iv">https://leetcode.cn/problems/spiral-matrix-iv</a></p>
<p><strong>示例</strong><br><img src="/2022/07/05/002-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2326.jpg" class title="This is an test image"></p>
<blockquote>
<p>输入：m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]<br>输出：[[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]<br>解释：上图展示了链表中的整数在矩阵中是如何排布的。<br>注意，矩阵中剩下的空格用 -1 填充。</p>
</blockquote>
<p><strong>思路</strong><br>在矩阵内四个方向依次轮转，当越界或者当前的格子已经填过数时，即转换方向</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrix</span>(<span class="type">int</span> m, <span class="type">int</span> n, ListNode* head) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;m;x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;n;++y)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[x][y] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>][<span class="number">0</span>] = head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j+dx[cur]&lt;<span class="number">0</span>||j+dx[cur]&gt;=n||i+dy[cur]&lt;<span class="number">0</span>||i+dy[cur]&gt;=m||ans[i+dy[cur]][j+dx[cur]]!=<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = (cur+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i+=dy[cur];j+=dx[cur];</span><br><span class="line">            ans[i][j] = head-&gt;val;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2327-知道秘密的人数（中等）"><a href="#2327-知道秘密的人数（中等）" class="headerlink" title="2327. 知道秘密的人数（中等）"></a>2327. 知道秘密的人数（中等）</h3><p>在第 1 天，有一个人发现了一个秘密。</p>
<p>给你一个整数 delay ，表示每个人会在发现秘密后的 delay 天之后，每天 给一个新的人 分享 秘密。同时给你一个整数 forget ，表示每个人在发现秘密 forget 天之后会 忘记 这个秘密。一个人 不能 在忘记秘密那一天及之后的日子里分享秘密。</p>
<p>给你一个整数 n ，请你返回在第 n 天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对 10e + 7 取余 后返回。</p>
<p>题目链接：<a href="https://leetcode.cn/problems/number-of-people-aware-of-a-secret">https://leetcode.cn/problems/number-of-people-aware-of-a-secret</a></p>
<p><strong>示例</strong></p>
<blockquote>
<p>输入：n = 6, delay = 2, forget = 4<br>输出：5<br>解释：<br>第 1 天：假设第一个人叫 A 。（一个人知道秘密）<br>第 2 天：A 是唯一一个知道秘密的人。（一个人知道秘密）<br>第 3 天：A 把秘密分享给 B 。（两个人知道秘密）<br>第 4 天：A 把秘密分享给一个新的人 C 。（三个人知道秘密）<br>第 5 天：A 忘记了秘密，B 把秘密分享给一个新的人 D 。（三个人知道秘密）<br>第 6 天：B 把秘密分享给 E，C 把秘密分享给 F 。（五个人知道秘密）</p>
</blockquote>
<p><strong>思路</strong><br>递推，动态规划</p>
<p><strong>解法1</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peopleAwareOfSecret</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> delay, <span class="type">int</span> forget)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">2</span>)); <span class="comment">//考虑用long long</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//dp[i][j]表示在第i天知道秘密天数为第j天的人</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=delay;j&lt;forget;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>] = (dp[i<span class="number">-1</span>][j]+dp[i][<span class="number">1</span>])%mod;</span><br><span class="line">                <span class="comment">//第i天新知道消息的人消息来源来自前一天知道消息delay天~forget天的人，求和</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=forget;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="comment">//第i天知道消息j天（j&gt;=2）的人是第i-1天知道消息j-1天的人</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=forget;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = (ans+dp[n][i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><strong>解法2</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peopleAwareOfSecret</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> delay, <span class="type">int</span> forget)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>)</span></span>;<span class="comment">//表示第i天新增的知道消息的人数</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i-forget+<span class="number">1</span>;j&lt;=i-delay;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] += dp[j];</span><br><span class="line">                    dp[i] = dp[i]%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=n-forget+<span class="number">1</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = (ans+dp[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="2328-网格图中递增路径的数目（困难）"><a href="#2328-网格图中递增路径的数目（困难）" class="headerlink" title="2328. 网格图中递增路径的数目（困难）"></a>2328. 网格图中递增路径的数目（困难）</h3><p>给你一个 m x n 的整数网格图 grid ，你可以从一个格子移动到 4 个方向相邻的任意一个格子。</p>
<p>请你返回在网格图中从 任意 格子出发，达到 任意 格子，且路径中的数字是 严格递增 的路径数目。由于答案可能会很大，请将结果对 10e9 + 7 取余 后返回。</p>
<p>如果两条路径中访问过的格子不是完全相同的，那么它们视为两条不同的路径</p>
<p>题目链接：<a href="https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid">https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid</a></p>
<p><strong>示例</strong><br><img src="https://assets.leetcode.com/uploads/2022/05/10/griddrawio-4.png" alt></p>
<blockquote>
<p>输入：grid = [[1,1],[3,4]]<br>输出：8<br>解释：严格递增路径包括：</p>
<pre><code>- 长度为 1 的路径：[1]，[1]，[3]，[4] 。
- 长度为 2 的路径：[1 -&gt; 3]，[1 -&gt; 4]，[3 -&gt; 4] 。
- 长度为 3 的路径：[1 -&gt; 3 -&gt; 4] 。
路径数目为 4 + 3 + 1 = 8 。
</code></pre></blockquote>
<p><strong>思路</strong><br>记忆化搜索<br>记录 f(i, j) 表示以 (i, j) 为结尾的不同路径有几条。计算 f(i,j) 时，检查 (i, j) 上下左右四个格子，若相邻格子里的数比当前格子里的数小，则可以转移给 f(i, j)。当然最后别忘了计算从 (i, j)开始，然后直接在 (i, j) 结束的路径，也就是 f(i, j) 还要再加 1。</p>
<p>用记忆化搜索即可在 $ O(nm) $ 的复杂度内完成。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; f;</span><br><span class="line">    <span class="comment">// long long f[1010][1010];</span></span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        f[x][y] = <span class="number">1</span>; <span class="comment">//长度为1的路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i) <span class="comment">//检查相邻格子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tx = x+dx[i];<span class="type">int</span> ty = y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(tx&lt;n&amp;&amp;tx&gt;=<span class="number">0</span>&amp;&amp;ty&lt;m&amp;&amp;ty&gt;=<span class="number">0</span>&amp;&amp;grid[x][y]&gt;grid[tx][ty])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!f[tx][ty]) <span class="built_in">dfs</span>(tx,ty,grid);</span><br><span class="line">                f[x][y] = (f[x][y]+f[tx][ty])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPaths</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n = grid.<span class="built_in">size</span>();</span><br><span class="line">        m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        f.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(m));</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(f[i][j]==<span class="number">0</span>) <span class="built_in">dfs</span>(i,j,grid);</span><br><span class="line">                ans = (ans+f[i][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="第132场周赛"><a href="#第132场周赛" class="headerlink" title="第132场周赛"></a>第132场周赛</h2><h3 id="5024-除数博弈（简单）"><a href="#5024-除数博弈（简单）" class="headerlink" title="5024. 除数博弈（简单）"></a>5024. 除数博弈（简单）</h3><p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。<br>最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：<br>选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。<br>用 N - x 替换黑板上的数字 N 。<br>如果玩家无法执行这些操作，就会输掉游戏。<br>只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。<br><strong>思路:</strong> 草稿纸手算各种情况，这种简单博弈论的题首先就判断奇偶的情况就对了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(N % <span class="number">2</span> == <span class="number">0</span>)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="5030-节点与其祖先之间的最大差值"><a href="#5030-节点与其祖先之间的最大差值" class="headerlink" title="5030.节点与其祖先之间的最大差值"></a>5030.节点与其祖先之间的最大差值</h3><p>给定二叉树的根节点 root，找出存在于不同节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。<br>（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）</p>
<p><strong>思路:</strong> 从根节点出发开始搜索，一方面比较当前节点和最大值/最小值的绝对值，一方面更新最大最小值，因为是顺着一条条支路走下去的，所以结果一定是祖先和其后代的差值<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * TreeNode *left;</span></span><br><span class="line"><span class="comment"> * TreeNode *right;</span></span><br><span class="line"><span class="comment"> * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> &amp;ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">ans = <span class="built_in">max</span>(ans,<span class="built_in">abs</span>(x-root-&gt;val));</span><br><span class="line">ans = <span class="built_in">max</span>(ans,<span class="built_in">abs</span>(y-root-&gt;val));</span><br><span class="line">x = <span class="built_in">max</span>(x,root-&gt;val);</span><br><span class="line">y = <span class="built_in">min</span>(y,root-&gt;val);</span><br><span class="line"><span class="built_in">dfs</span>(root-&gt;left,x,y,ans);</span><br><span class="line"><span class="built_in">dfs</span>(root-&gt;right,x,y,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x,y;x = y = root-&gt;val;</span><br><span class="line"><span class="built_in">dfs</span>(root,x,y,ans);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="5025-最长等差数列"><a href="#5025-最长等差数列" class="headerlink" title="5025. 最长等差数列"></a>5025. 最长等差数列</h3><p>给定一个整数数组 A，返回 A 中最长等差子序列的长度。<br><strong>思路：</strong> 设置一个dp[i][j],表示以i结尾的差值为j的最长等差序列的个数，但要注意，这里不能用二维数组，因为j有可能为负数，所以最省力的做法就是unordered_map</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestArithSeqLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; dp[<span class="number">2005</span>];</span><br><span class="line"><span class="type">int</span> len = A.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> ans = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; len; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cha = A[j]-A[i];</span><br><span class="line">dp[j][cha]=<span class="built_in">max</span>(dp[j][cha],dp[i][cha]+<span class="number">1</span>);</span><br><span class="line">ans = <span class="built_in">max</span>(ans,dp[j][cha]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2022/07/02/001-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<!-- ![这里输入图片描述](/力扣.png) -->
<!-- ![](/img/leetcode.png) -->
<!-- <img src="/2022/07/02/001-%E4%BD%8D%E8%BF%90%E7%AE%97/leetcode.png" class="" title="This is an test image"> -->
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191.位1的个数"></a>191.位1的个数</h3><p>题目链接：<a href="https://leetcode.cn/problems/number-of-1-bits/">https://leetcode.cn/problems/number-of-1-bits/</a></p>
<p>若 $n = 2^x$  且 x为自然数（即 n 为 2 的幂），则恒有 $ n \&amp;(n - 1) == 0 $ ，这是因为：<br>$n$ 二进制最高位为 1，其余所有位为0；<br>$n−1$ 二进制最高位为 0，其余所有位为 1；<br><!-- ![](/1.png) --><br><img src="/2022/07/02/001-%E4%BD%8D%E8%BF%90%E7%AE%97/1.png" class title="This is an test image"></p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="and运算-amp"><a href="#and运算-amp" class="headerlink" title="and运算&amp;"></a>and运算&amp;</h3><p>  and运算通常用于二进制的取位操作，例如一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数。<br>相同位的两个数字都为1，则为1；若有一个不为1，则为0。</p>
<h3 id="or运算"><a href="#or运算" class="headerlink" title="or运算 |"></a>or运算 |</h3><p>or运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。<br>相同位只要一个为1即为1。</p>
<h3 id="xor运算"><a href="#xor运算" class="headerlink" title="xor运算 ^"></a>xor运算 ^</h3><p>异或的符号是^。按位异或运算, 对等长二进制模式按位或二进制数的每一位执行逻辑按位异或操作. 操作的结果是如果某位不同则该位为1, 否则该位为0.<br>xor运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即(a xor b) xor b = a。xor运算可以用于简单的加密。<br>相同位不同则为1，相同则为0。</p>
<h3 id="not运算"><a href="#not运算" class="headerlink" title="not运算 ~"></a>not运算 ~</h3><p>not运算的定义是把内存中的0和1全部取反。使用not运算时要格外小心，你需要注意整数类型有没有符号。如果not的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用00到$FFFF依次表示的。</p>
<h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h3><p>a &lt;&lt; b就表示把a转为二进制后左移b位（在后面添b个0）。例如100的二进制为1100100，而110010000转成十进制是400，那么100 shl 2 = 400。可以看出，a shl b的值实际上就是a乘以2的b次方，因为在二进制数后添一个0就相当于该数乘以2。<br>通常认为a &lt;&lt; 1比a * 2更快，因为前者是更底层一些的操作。因此程序中乘以2的操作请尽量用左移一位来代替。<br>定义一些常量可能会用到&lt;&lt;运算。你可以方便地用1 &lt;&lt; 16 - 1来表示65535。很多算法和数据结构要求数据规模必须是2的幂，此时可以用&lt;&lt;来定义Max_N等常量。</p>
<h3 id="带符号右移-gt-gt"><a href="#带符号右移-gt-gt" class="headerlink" title="带符号右移&gt;&gt;"></a>带符号右移&gt;&gt;</h3><p>和&lt;&lt;相似，a &gt;&gt; b表示二进制右移b位（去掉末b位,最左边用0填充），相当于a除以2的b次方（取整）。和上面一样的例子，那么400 &gt;&gt;2 = 100。我们也经常用&gt;&gt;1来代替div 2，比如二分查找、堆的插入操作等等。想办法用&gt;&gt;代替除法运算可以使程序效率大大提高。最大公约数的二进制算法用除以2操作来代替慢得出奇的mod运算，效率可以提高60%。</p>
<h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 整数集合set位运算</span><br><span class="line"># 整数集合做标志时，比如回溯时的visited标志数组</span><br><span class="line">vstd 访问 i ：vstd | (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">vstd 离开 i ：vstd &amp; ~(<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">vstd 不包含 i : <span class="keyword">not</span> vstd &amp; (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">并集 ：A | B</span><br><span class="line">交集 ：A &amp; B</span><br><span class="line">全集 ：(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line">补集 ：((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) ^ A</span><br><span class="line">子集 ：(A &amp; B) == B</span><br><span class="line">判断是否是 <span class="number">2</span> 的幂 ：A &amp; (A - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">最低位的 <span class="number">1</span> 变为 <span class="number">0</span> ：n &amp;= (n - <span class="number">1</span>)</span><br><span class="line">最低位的 <span class="number">1</span>：A &amp; (-A)，最低位的 <span class="number">1</span> 一般记为 <span class="built_in">lowbit</span>(A)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab的安装及破译</title>
    <url>/2019/04/01/004-Matlab%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%A0%B4%E8%AF%91/</url>
    <content><![CDATA[<p>写在前面：和数字图像处理一段不解之缘的开始（ps：已换电脑，还没重装matlab）</p>
<p><strong>第一步</strong><br>放上下载链接<br>链接: <a href="https://pan.baidu.com/s/1nxw14nOfQeMiYYLmkNO-cw">https://pan.baidu.com/s/1nxw14nOfQeMiYYLmkNO-cw</a><br>提取码:dw1h<br>（版本为2017a，文件内容过大，所以分成了两部分，建议下载之后新建一个文件夹，将两部分解压至一处）</p>
<p><strong>第二步</strong><br>点击setup.exe，等待稍许，出现如下界面，选择使用文件安装密钥<br><img src="/2019/04/01/004-Matlab%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%A0%B4%E8%AF%91/1.jpg" class title="This is an test image"></p>
<p><strong>第三步</strong><br>输入文件安装密钥，可在破译文件中找到<br><img src="/2019/04/01/004-Matlab%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%A0%B4%E8%AF%91/%E5%AE%89%E8%A3%852.png" class title="This is an test image"><br><strong>第四步</strong><br>选择合适的位置安装位置，文件较大，不建议使用系统默认盘</p>
<p><strong>第五步</strong><br>勾选全部产品，等待安装</p>
<img src="/2019/04/01/004-Matlab%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%A0%B4%E8%AF%91/%E5%AE%89%E8%A3%853.png" class title="This is an test image">
<p>很久很久之后……<br><strong>第六步</strong><br>（如果没有将将部分解压到同一个文件夹，这个过程会暂停，此时仍需要把part2中的两个文件复制到1所在文件夹）<br>安装完成后，点击bin目录下的matlab.exe，进行软件激活<br><strong>第七步</strong><br>选择“在不使用Internet的情况下激活”，与此同时，将破译文件下的license_standalone.lic 复制到 \MATLAB\R2017a\licenses\，netapi32.dll 复制到 \MATLAB\R2017a\bin\win64\<br><strong>第八步</strong><br>输入许可证文件的完整路径，即为刚刚复制的license_standalone.lic</p>
<p>大功告成</p>
]]></content>
      <categories>
        <category>经验记录</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>数据集汇总和介绍</title>
    <url>/2022/07/04/003-%E6%95%B0%E6%8D%AE%E9%9B%86%E6%B1%87%E6%80%BB%E5%92%8C%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/mou_it/article/details/82225505">https://blog.csdn.net/mou_it/article/details/82225505</a></p>
<p><a href="https://www.jianshu.com/p/16b2e32d9edf">https://www.jianshu.com/p/16b2e32d9edf</a></p>
<p>目标检测开源数据集： <a href="https://mp.weixin.qq.com/s/M-RnUKaHeZg5-yJU2WDuhA">https://mp.weixin.qq.com/s/M-RnUKaHeZg5-yJU2WDuhA</a></p>
<p><a href="https://arxiv.org/pdf/2208.06283v1.pdf">染色牙菌斑数据集</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>数据集</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces刷题记录</title>
    <url>/2019/04/17/005-Codeforces%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Codeforces-552-Div-3"><a href="#Codeforces-552-Div-3" class="headerlink" title="Codeforces 552 (Div. 3)"></a>Codeforces 552 (Div. 3)</h2><h3 id="A-Restoring-Three-Numbers"><a href="#A-Restoring-Three-Numbers" class="headerlink" title="A. Restoring Three Numbers"></a>A. Restoring Three Numbers</h3><p><strong>题意</strong>：给你四个数，a+b，a+c，b+c，a+b+c，（abc都为正数，可以相等）让你找出满足条件的a、b、c的值，排名不分先后<br><strong>思路</strong>：找出四个数中最大的数，减去其他三个就ok了了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">6</span>];</span><br><span class="line">    <span class="type">int</span> maxn = <span class="number">0</span>,flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; maxn)</span><br><span class="line">        &#123;</span><br><span class="line">            maxn = a[i];flag = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,maxn-a[i]);</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt&lt;=<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="B-Make-Them-Equal"><a href="#B-Make-Them-Equal" class="headerlink" title="B. Make Them Equal"></a>B. Make Them Equal</h3><p><strong>题意</strong>：给定一个序列，让其中的每一个数通过+x，-x，或不变三种方式变成同一个数，求最小的非负数x，不存在输出-1<br><strong>思路</strong>：数列中超过三种数肯定是错的，所以先用set求不同数的个数<br>如果只有一种数，每个数不变就好，答案为0；<br>两种，有两个情况，他们有中位数，直接中间的数减去小的数，没有就只能是两个数的差值；<br>三种，只有等差数列才满足条件<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,tem;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>,b = <span class="number">0</span>,c = <span class="number">0</span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; ::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tem);</span><br><span class="line">        s.<span class="built_in">insert</span>(tem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i++] = *it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = num[<span class="number">1</span>]+num[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum/<span class="number">2</span>-num[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num[<span class="number">2</span>]-num[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = num[<span class="number">1</span>]+num[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>(sum == num[<span class="number">2</span>]*<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num[<span class="number">2</span>]-num[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="C-Gourmet-Cat"><a href="#C-Gourmet-Cat" class="headerlink" title="C. Gourmet Cat"></a>C. Gourmet Cat</h3><p>这一题当时思索了一下，先跳过去写D，然后再重新思考，交题的时候刚好断网，换卡开热点开写<br><strong>题意</strong>：一只猫从星期一到星期天每天固定只吃1 2 3 1 3 2 1类食物，三类食物分别有a、b、c数量，主人想出去旅游，从星期几开始无所谓，问这只贵气的猫最多能撑多久<br><strong>思路</strong>：数据比较大啊……($1≤a,b,c≤7⋅10^8$)不能纯暴力。可以看出每周1、2、3类食物消耗的量分别是3、2、2，于是先用a、b、c除以3、2、2，看看哪种食物最不能撑<br>然后分别多留出一周，分三种情况暴力处理从一周每一天开始的情况，求出坚持最大天数才使三类存粮最慢消耗为负数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">200005</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,a,b,c;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">8</span>][<span class="number">15</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    x = a/<span class="number">3</span>;</span><br><span class="line">    y = b/<span class="number">2</span>;</span><br><span class="line">    z = c/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=y&amp;&amp;x&lt;=z)</span><br><span class="line">    &#123;</span><br><span class="line">        x--;</span><br><span class="line">        ans+=x*<span class="number">7</span>;</span><br><span class="line">        a-=<span class="number">3</span>*x;b-=<span class="number">2</span>*x;c-=<span class="number">2</span>*x;</span><br><span class="line">        <span class="type">int</span> ma=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            x=a,y=b,z=c;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">14</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i][j]==<span class="number">1</span>) x--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i][j]==<span class="number">2</span>) y--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i][j]==<span class="number">3</span>) z--;</span><br><span class="line">                <span class="keyword">if</span>(y&lt;<span class="number">0</span>||x&lt;<span class="number">0</span>||z&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            ma=<span class="built_in">max</span>(ma,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=ma;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(y&lt;x&amp;&amp;y&lt;z)</span><br><span class="line">    &#123;</span><br><span class="line">        y--;</span><br><span class="line">        ans+=y*<span class="number">7</span>;</span><br><span class="line">        a-=<span class="number">3</span>*y;b-=<span class="number">2</span>*y;c-=<span class="number">2</span>*y;</span><br><span class="line">        <span class="type">int</span> ma=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            x=a,y=b,z=c;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">14</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i][j]==<span class="number">1</span>) x--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i][j]==<span class="number">2</span>) y--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i][j]==<span class="number">3</span>) z--;</span><br><span class="line">                <span class="keyword">if</span>(y&lt;<span class="number">0</span>||x&lt;<span class="number">0</span>||z&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            ma=<span class="built_in">max</span>(ma,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=ma;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        z--;</span><br><span class="line">        ans+=z*<span class="number">7</span>;</span><br><span class="line">        a-=<span class="number">3</span>*z;b-=<span class="number">2</span>*z;c-=<span class="number">2</span>*z;</span><br><span class="line">        <span class="type">int</span> ma=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            x=a,y=b,z=c;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">14</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i][j]==<span class="number">1</span>) x--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i][j]==<span class="number">2</span>) y--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i][j]==<span class="number">3</span>) z--;</span><br><span class="line">                <span class="keyword">if</span>(y&lt;<span class="number">0</span>||x&lt;<span class="number">0</span>||z&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            ma=<span class="built_in">max</span>(ma,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=ma;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="D-Walking-Robot"><a href="#D-Walking-Robot" class="headerlink" title="D. Walking Robot"></a>D. Walking Robot</h3><p><strong>题意:</strong> 一个机器人要从0走到n，它拥有b节普通电池和a节太阳能蓄力电池，每走一步路需要消耗一节电池，这段路上另外有个数组si表示i-1到i处是否有太阳，为1表示有太阳，有阳光的话可以给不在使用的太阳能蓄力电池充电，求小机器人最多能走几步（n封顶）<br><strong>思路:</strong> 一遍模拟，精髓就在于一定要先用太阳能电池，其他没啥了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">200005</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,a,b,x,y;</span><br><span class="line">    <span class="type">int</span> s[maxn];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;a,&amp;b);</span><br><span class="line">    x = a; y = b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;b&amp;&amp;x&gt;<span class="number">0</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            y++;x--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            y--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = i;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">    <span class="keyword">else</span>    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习和部分代码</title>
    <url>/2019/10/18/007-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h3 id="线性回归最小二乘法代码"><a href="#线性回归最小二乘法代码" class="headerlink" title="线性回归最小二乘法代码"></a>线性回归最小二乘法代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">points = np.genfromtxt(<span class="string">&#x27;data.txt&#x27;</span>,delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">x = points[:,<span class="number">0</span>]<span class="comment">#第一列数据</span></span><br><span class="line">y = points[:,<span class="number">1</span>]</span><br><span class="line">plt.scatter(x,y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_cost</span>(<span class="params">w,b,points</span>):</span><br><span class="line">    total_cost = <span class="number">0</span></span><br><span class="line">    M = <span class="built_in">len</span>(points)</span><br><span class="line">    <span class="comment">#逐点计算实际数据与模型数据的平方差，求平均值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        x = points[i,<span class="number">0</span>]</span><br><span class="line">        y = points[i,<span class="number">1</span>]</span><br><span class="line">        total_cost += (y - w*x - b)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_cost/M</span><br><span class="line"><span class="comment">#定义求均值函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    num = <span class="built_in">len</span>(data)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="built_in">sum</span>+=data[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>/num</span><br><span class="line"><span class="comment">#定义核心拟函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">points</span>):</span><br><span class="line">    M = <span class="built_in">len</span>(points)</span><br><span class="line">    x_bar = average(points[:,<span class="number">0</span>])</span><br><span class="line">    sum_yx = <span class="number">0</span></span><br><span class="line">    sum_x2 = <span class="number">0</span></span><br><span class="line">    sum_delta = <span class="number">0</span></span><br><span class="line">    <span class="comment">#根据公式计算w</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        x = points[i,<span class="number">0</span>]</span><br><span class="line">        y = points[i,<span class="number">1</span>]</span><br><span class="line">        sum_yx += y * (x - x_bar)</span><br><span class="line">        sum_x2 += x**<span class="number">2</span></span><br><span class="line">    w = sum_yx / (sum_x2 - M * (x_bar**<span class="number">2</span>))</span><br><span class="line">    <span class="comment">#根据公式计算b</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        x = points[i,<span class="number">0</span>]</span><br><span class="line">        y = points[i,<span class="number">1</span>]</span><br><span class="line">        sum_delta += y - w*x</span><br><span class="line">    b = sum_delta / M</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> w,b</span><br><span class="line"></span><br><span class="line">w,b = fit(points)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w is :&#x27;</span>,w)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b is :&#x27;</span>,b)</span><br><span class="line">cost = compute_cost(w,b,points)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cost is :&#x27;</span>,cost)</span><br><span class="line"></span><br><span class="line">pred_y = w*x + b</span><br><span class="line">plt.plot(x, pred_y, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="sklearn线性回归"><a href="#sklearn线性回归" class="headerlink" title="sklearn线性回归"></a>sklearn线性回归</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">boston = load_boston()</span><br><span class="line">x = boston.data[:,<span class="number">5</span>:<span class="number">6</span>]<span class="comment">#取数据第五列为x的值</span></span><br><span class="line">y = boston.target</span><br><span class="line"><span class="comment">#建立线性回归模型</span></span><br><span class="line">regre = LinearRegression()</span><br><span class="line">model2 = regre.fit(x,y)</span><br><span class="line">a = regre.coef_ <span class="comment">#直线的斜率</span></span><br><span class="line">b = regre.intercept_ <span class="comment">#直线的截距</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y = %d * x + (%d)&quot;</span>%(a,b))</span><br><span class="line">pre = model2.predict(x)</span><br><span class="line"><span class="comment">#真实的点</span></span><br><span class="line">plt.scatter(x,y,color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="comment">#拟合的直线</span></span><br><span class="line">plt.plot(x,pre)</span><br><span class="line">plt.show()</span><br><span class="line">plt.close()</span><br></pre></td></tr></table></figure>
<h3 id="线性回归标准方程法"><a href="#线性回归标准方程法" class="headerlink" title="线性回归标准方程法"></a>线性回归标准方程法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_wb</span>(<span class="params">X,y</span>):</span><br><span class="line">    <span class="keyword">if</span> np.linalg.det(X.T*X)!=<span class="number">0</span>:</span><br><span class="line">        wb = ((X.T.dot(X).I).dot(X.T)).dot(y)</span><br><span class="line">        <span class="keyword">return</span> wb</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">x,wb</span>):</span><br><span class="line">    <span class="keyword">return</span> x.T.dot(wb)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getdata</span>():</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    file = <span class="built_in">open</span>(<span class="string">&quot;ex0.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file.readlines():</span><br><span class="line">        temp = line.strip().split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        x.append([<span class="built_in">float</span>(temp[<span class="number">0</span>]),<span class="built_in">float</span>(temp[<span class="number">1</span>])])</span><br><span class="line">        y.append(<span class="built_in">float</span>(temp[<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">return</span> (np.mat(x),np.mat(y).T)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">x,y,wb</span>):</span><br><span class="line">    a = np.linspace(<span class="number">0</span>,np.<span class="built_in">max</span>(x)) <span class="comment">#等差数列函数</span></span><br><span class="line">    b = wb[<span class="number">0</span>] + a*wb[<span class="number">1</span>]</span><br><span class="line">    plot(x,y,<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    plot(a,b)</span><br><span class="line">    show()</span><br><span class="line"></span><br><span class="line">X,y = getdata()</span><br><span class="line">wb = train_wb(X,y)</span><br><span class="line">draw(X[:,<span class="number">1</span>],y,wb.tolist())</span><br></pre></td></tr></table></figure>
<h3 id="KNN算法"><a href="#KNN算法" class="headerlink" title="KNN算法"></a>KNN算法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadDataSet</span>(<span class="params">fileName</span>):</span><br><span class="line">    dataMat = []</span><br><span class="line">    fr = <span class="built_in">open</span>(fileName)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        lineArr = []</span><br><span class="line">        curLine = line.strip().split()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(curLine)):</span><br><span class="line">            lineArr.append(<span class="built_in">float</span>(curLine[i]))</span><br><span class="line">        dataMat.append(lineArr)</span><br><span class="line">    dataArr = np.array(dataMat)</span><br><span class="line">    <span class="keyword">return</span> dataArr</span><br><span class="line"></span><br><span class="line">dataArr = loadDataSet(<span class="string">&#x27;diabetes_train.txt&#x27;</span>)</span><br><span class="line">testArr = loadDataSet(<span class="string">&#x27;diabetes_train.txt&#x27;</span>)</span><br><span class="line">labels = dataArr[:,:<span class="number">1</span>]</span><br><span class="line">testlabel = testArr[:,:<span class="number">1</span>]</span><br><span class="line">dataArr = dataArr[:,<span class="number">1</span>:]</span><br><span class="line">testArr = testArr[:,<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">kNN</span>(<span class="params">dataArr,labels,testArr,k</span>):</span><br><span class="line">    testAns = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(testArr)):</span><br><span class="line">        distSquareMat = (dataArr - testArr[i]) ** <span class="number">2</span>  <span class="comment"># 计算差值的平方</span></span><br><span class="line">        distSquareSums = distSquareMat.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">        distance = distSquareSums**<span class="number">0.5</span></span><br><span class="line">        sortedIndices = distance.argsort()<span class="comment">#排序，得到排序后的下标</span></span><br><span class="line">        indices = sortedIndices[:k]</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> indices:</span><br><span class="line">            labe = labels[j]</span><br><span class="line">            <span class="keyword">if</span> labe == <span class="number">1</span> :</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> num &gt; (k-num):</span><br><span class="line">            testAns.append([<span class="number">1.0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            testAns.append([<span class="number">0.0</span>])</span><br><span class="line">    <span class="keyword">return</span> testAns</span><br><span class="line"></span><br><span class="line">ans = kNN(dataArr,labels,testArr,<span class="number">5</span>)</span><br><span class="line">length = testlabel.shape[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;糖尿病测试集原结果如下：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(testlabel.tolist())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;5近邻算法求得测试集结果如下：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line">lostSum = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>):</span><br><span class="line">    ans = kNN(dataArr,labels,testArr,i)</span><br><span class="line">    lost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        lost += <span class="built_in">abs</span>( <span class="built_in">int</span>( ans[j]-testlabel[j] ) )</span><br><span class="line">    <span class="comment">#lostSum.append(lost)</span></span><br><span class="line">    lostSum[i] = lost</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;当k取值为如下奇数时，预测错误个数分别为：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(lostSum)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>研究生期间</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2022/07/10/006-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>[TOC]</p>
<p><strong>写在前面</strong><br>本文参考：<a href="https://leetcode.cn/problemset/all/">力扣题解</a>   <a href="https://www.programmercarl.com/">代码随想录</a></p>
<h2 id="一些要素"><a href="#一些要素" class="headerlink" title="一些要素"></a>一些要素</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">最小值 </span><br><span class="line">INT_MIN</span><br></pre></td></tr></table></figure>
<h2 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">（针对整型数据 vector&lt;<span class="type">int</span>&gt; a）</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）插入元素</span><br><span class="line">a.<span class="built_in">push_back</span>() —— 在数组的最后插入元素</span><br><span class="line">a.<span class="built_in">emplace_back</span>() —— 在数组的最后插入元素</span><br><span class="line">a.<span class="built_in">insert</span>()</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）删除数据</span><br><span class="line">a.<span class="built_in">pop_back</span>() —— 删除数组的最后一个数据</span><br><span class="line">a.erase —— 删除指针指向的数据项</span><br><span class="line">a.clear —— 清空当前的vector</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）查找数据</span><br><span class="line">a.<span class="built_in">at</span>(x) —— 获取位置x的元素</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）获取向量属性</span><br><span class="line">a.<span class="built_in">size</span>() —— 当前向量的长度</span><br><span class="line">a.max_size 得到vector最大长度</span><br><span class="line">a.capacity —— 当前vector分配的大小</span><br><span class="line">a.begin —— 得到数组头的指针</span><br><span class="line">a.end —— 得到数组的最后一个单元+<span class="number">1</span>的指针</span><br><span class="line">a.front —— 得到数组头的引用</span><br><span class="line">a.back —— 得到数组的最后一个单元的引用</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）其它</span><br><span class="line">a.rbegin —— 将vector反转后的开始指针返回(其实就是原来的end<span class="number">-1</span>)</span><br><span class="line">a.rend —— 将vector反转构的结束指针返回(其实就是原来的begin<span class="number">-1</span>)</span><br><span class="line">a.empty —— 判断vector是否为空</span><br><span class="line">a.swap —— 与另一个vector交换数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><strong>multiset</strong><br><strong>unordered_set</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">se.<span class="built_in">count</span>(x) —— 判断有无某元素</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : se) —— 遍历集合</span><br></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><strong>unordered_map</strong></p>
<p>map遍历的几种方式<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a:mp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it) </span><br><span class="line">&#123;</span><br><span class="line">    ans.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line">mp[key].<span class="built_in">emplace_back</span>(str);</span><br></pre></td></tr></table></figure></p>
<h2 id="C-库函数"><a href="#C-库函数" class="headerlink" title="C++库函数"></a>C++库函数</h2><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + s.<span class="built_in">size</span>()); - 反转字符串</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><strong>思路</strong><br>二分查找涉及的很多的边界条件，逻辑容易绕混，例如到底是 while(left &lt; right) 还是 while(left &lt;= right)，到底是right = middle呢，还是要right = middle - 1呢？</p>
<p><strong>34. 在排序数组中查找元素的第一个和最后一个位置【中等】</strong><br>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题</p>
<p>题目链接：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array</a></p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums = [5,7,7,8,8,10], target = 8<br>输出：[3,4]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：nums = [5,7,7,8,8,10], target = 6<br>输出：[-1,-1]</p>
</blockquote>
<p><strong>自己代码实现：</strong> 老老实实分两个区间来二分查找左边界和右边界<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">-1</span>, end = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right) <span class="comment">//寻找start</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&lt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&gt;target)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = middle<span class="number">-1</span>;</span><br><span class="line">                start = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(start);</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right) <span class="comment">//寻找end</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&lt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&gt;target)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = middle+<span class="number">1</span>;</span><br><span class="line">                end = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(end);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p><strong>27. 移除元素【简单】</strong><br>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>题目链接：<a href="https://leetcode.cn/problems/remove-element">https://leetcode.cn/problems/remove-element</a><br><strong>示例</strong></p>
<blockquote>
<p>输入：nums = [0,1,2,2,3,0,4,2], val = 2<br>输出：5, nums = [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p><strong>思路</strong><br>输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置。</p>
<p>如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</p>
<p>如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位。</p>
<p>整个过程保持不变的性质是：区间 [0,left) 中的元素都不等于 val。当左右指针遍历完输入数组以后，left 的值就是输出数组的长度。</p>
<p>这样的算法在最坏情况下（输入数组中没有元素等于val），左右指针各遍历了数组一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> first = <span class="number">0</span>, second = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(first = <span class="number">0</span>; first &lt; nums.<span class="built_in">size</span>(); ++first)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[first]!=val)&#123;</span><br><span class="line">                nums[second++] = nums[first];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>双指针优化</strong></p>
<p>如果要移除的元素恰好在数组的开头，例如序列 [1,2,3,4,5]，当 val 为 1 时，我们需要把每一个元素都左移一位。注意到题目中说：「元素的顺序可以改变」。实际上我们可以直接将最后一个元素 55 移动到序列开头，取代元素 1，得到序列 [5,2,3,4]，同样满足题目要求。这个优化在序列中 val 元素的数量较少时非常有效。</p>
<p>此时的双指针解法应将两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。</p>
<p>如果左指针left 指向的元素等于val，此时将右指针 right 指向的元素复制到左指针left 的位置，然后右指针 right 左移一位。如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖，直到左指针指向的元素的值不等于 val 为止。</p>
<p>当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素。</p>
<p>这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。且此方法避免了需要保留的元素的重复赋值操作。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]==val)&#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>844. 比较含退格的字符串</strong><br>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</p>
<p>注意：如果对空文本输入退格字符，文本继续为空。</p>
<p>题目链接：<a href="https://leetcode.cn/problems/backspace-string-compare">https://leetcode.cn/problems/backspace-string-compare</a></p>
<p><strong>示例</strong></p>
<blockquote>
<p>输入：s = “ab#c”, t = “ad#c”<br>输出：true<br>解释：s 和 t 都会变成 “ac”。</p>
</blockquote>
<p><strong>方法一：重构字符串</strong></p>
<p>最容易想到的方法是将给定的字符串中的退格符和应当被删除的字符都去除，还原给定字符串的一般形式。然后直接比较两字符串是否相等即可。</p>
<p>具体地，我们用栈处理遍历过程，每次我们遍历到一个字符：</p>
<p>如果它是退格符，那么我们将栈顶弹出；</p>
<p>如果它是普通字符，那么我们将其压入栈中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123; <span class="comment">//***遍历字符串的新姿势，学着点</span></span><br><span class="line">            <span class="keyword">if</span>(c!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!ret.<span class="built_in">empty</span>())&#123; <span class="comment">//这一步千万不能忘，要记得判断字符串是否为空</span></span><br><span class="line">                ret.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>(s)==<span class="built_in">get</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(N+M)，其中 N 和 M 分别为字符串 S 和 T 的长度。我们需要遍历两字符串各一次。</p>
</li>
<li><p>空间复杂度：O(N+M)，其中 N 和 M 分别为字符串 S 和 T 的长度。主要为还原出的字符串的开销。</p>
</li>
</ul>
<p><strong>方法二：双指针</strong><br>一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。</p>
<p>具体地，我们定义 skip 表示当前待删除的字符的数量。每次我们遍历到一个字符：</p>
<p>若该字符为退格符，则我们需要多删除一个普通字符，我们让 skip 加 1；</p>
<p>若该字符为普通字符：</p>
<ul>
<li>若 skip 为 0，则说明当前字符不需要删去；</li>
<li>若 skip 不为 0，则说明当前字符需要删去，我们让 skip 减 1。</li>
</ul>
<p>这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; <span class="comment">//代码较复杂</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = S.<span class="built_in">length</span>() - <span class="number">1</span>, j = T.<span class="built_in">length</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> skipS = <span class="number">0</span>, skipT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S[i] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    skipS++, i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipS &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    skipS--, i--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (T[j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    skipT++, j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipT &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    skipT--, j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S[i] != T[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i--, j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>977. 有序数组的平方</strong><br>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。<br>题目链接：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array">https://leetcode.cn/problems/squares-of-a-sorted-array</a><br><strong>示例</strong></p>
<blockquote>
<p>输入：nums = [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]</p>
</blockquote>
<p><strong>之前写法</strong><br> 先找到首个大于零的位置坐标，然后以此坐标为中点分别向两边正负数去延申，依次比较大小再放入数组，姑且也勉强算是双指针？<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> flag = len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = nums[i]*nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="type">int</span> negative = flag<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> positive = flag;</span><br><span class="line">        <span class="keyword">while</span>(negative&gt;=<span class="number">0</span> || positive&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(negative&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums[positive]);</span><br><span class="line">                positive ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(positive&gt;=len)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums[negative]);</span><br><span class="line">                negative--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[negative] &lt; nums[positive])&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums[negative]);</span><br><span class="line">                negative--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[negative] &gt;= nums[positive])&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums[positive]);</span><br><span class="line">                positive++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><strong>首尾双指针法</strong><br>数组是有序的，那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p>
<p>考虑双指针法了，i 指向起始位置，j 指向终止位置。</p>
<p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p>
<p>如果A[i] <em> A[i] &lt; A[j] </em> A[j] 那么result[k—] = A[j] * A[j]; 。</p>
<p>如果A[i] <em> A[i] &gt;= A[j] </em> A[j] 那么result[k—] = A[i] * A[i]; 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;=j;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]*nums[i]&lt;nums[j]*nums[j])&#123;</span><br><span class="line">                ans[k--] = nums[j]*nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans[k--] = nums[i]*nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><strong>209. 长度最小的子数组【中等】</strong><br>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [nums[l], nums[l+1], …, nums[r-1], nums[r]] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p>题目链接：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum">https://leetcode.cn/problems/minimum-size-subarray-sum</a></p>
<p><strong>思路</strong><br>所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。</p>
<p>在本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
<p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p>
<p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//滑动窗口也算是双指针的一种吧</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = INT32_MAX;  <span class="comment">//定义最大数 或INT_MAX</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;nums.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res,j-i+<span class="number">1</span>);</span><br><span class="line">                sum-=nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res==INT32_MAX ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></p>
<blockquote>
<p>前面求的是最小滑窗，本题求的是最大滑窗<br>关键的区别在于，最大滑窗是在迭代右移右边界的过程中更新结果，而最小滑窗是在迭代右移左边界的过程中更新结果。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//set&lt;int&gt; se; 一开始打算用集合set，写完发现while循环的时候set弹出一次就没了</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;fruits.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            mp[fruits[j]]++;</span><br><span class="line">            <span class="keyword">while</span>(mp.<span class="built_in">size</span>()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">                mp[fruits[i]]--;</span><br><span class="line">                <span class="keyword">if</span> (mp[fruits[i]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    mp.<span class="built_in">erase</span>(fruits[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res,j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a>【困难】</p>
<blockquote>
<p>用一个哈希表表示 t 中所有的字符以及它们的个数，用一个哈希表动态维护窗口中所有的字符以及它们的个数，如果这个动态表中包含 t 的哈希表中的所有字符，并且对应的个数都不小于 t 的哈希表中各个字符的个数，那么当前的窗口是可行的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp,smp;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123; <span class="comment">//哈希表的比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p: mp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (smp[p.first] &lt; p.second) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = INT_MAX, ans_start=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:t)&#123;</span><br><span class="line">            mp[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;s.<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[s[j]])&#123;</span><br><span class="line">                smp[s[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">check</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i+<span class="number">1</span>&lt;res)</span><br><span class="line">                &#123;</span><br><span class="line">                    res = j-i+<span class="number">1</span>;</span><br><span class="line">                    ans_start = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(mp[s[i]])&#123;</span><br><span class="line">                    smp[s[i]]--;               </span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_start==<span class="number">-1</span> ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(ans_start,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><p><strong>59. 螺旋矩阵 II【中等】</strong><br>给你一个正整数 n ，生成一个包含 1 到 n<em>n 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。<br><em>*示例</em></em><br><img src="/2022/07/10/006-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/59%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5.png" class title="This is an test image"></p>
<blockquote>
<p>输入：n = 3<br>输出：[ [1,2,3],[8,9,4],[7,6,5] ]</p>
</blockquote>
<p><strong>思路</strong><br>这道题蔚来周赛的时候做过类似的<a href="https://leetcode.cn/problems/spiral-matrix-iv/">2326. 螺旋矩阵 IV</a>，在矩阵内四个方向依次轮转，当越界或者当前的格子已经填过数时，即转换方向，这种方法比按层模拟要清楚很多<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;<span class="comment">//记录当前转换到哪个方向</span></span><br><span class="line">        mat[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n*n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x+dx[cur]&gt;=n||x+dx[cur]&lt;<span class="number">0</span>||y+dy[cur]&gt;=n||y+dy[cur]&lt;<span class="number">0</span>||mat[x+dx[cur]][y+dy[cur]])</span><br><span class="line">            &#123;</span><br><span class="line">                cur = (cur+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x + dx[cur];</span><br><span class="line">            y = y + dy[cur];</span><br><span class="line">            mat[x][y] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>链表的定义</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);<span class="comment">//通过自己定义构造函数初始化节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//力扣中的定义链表</span></span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line"> *     <span class="type">int</span> val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"> *     <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"> *     <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>温馨提示</strong><br>做链表的题尽量多画图去分析</p>
<h3 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a><br>设置一个虚拟头结点在进行移除节点操作：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyNode-&gt;next = head;</span><br><span class="line">        ListNode* temp = dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;next-&gt;val==val)&#123;</span><br><span class="line">                ListNode *nn = temp-&gt;next;</span><br><span class="line">                temp-&gt;next = nn-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> nn ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h3><p><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a><br>比较复杂</p>
<h3 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表*"></a>翻转链表*</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p>
<p><strong>图示</strong><br><img src="/2022/07/10/006-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.gif" class title="This is an test image"></p>
<p><strong>迭代法</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* temp; <span class="comment">// 保存cur的下一个节点</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            temp = cur-&gt;next;  <span class="comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span></span><br><span class="line">            cur-&gt;next = pre; <span class="comment">// 翻转操作</span></span><br><span class="line">            <span class="comment">// 更新pre 和 cur指针</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>递归法</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* cur,ListNode* pre)</span> </span>&#123; <span class="comment">//迭代法</span></span><br><span class="line">        <span class="keyword">if</span>(!cur)&#123;</span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(temp,cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123; <span class="comment">//迭代法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(head,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode *cur = dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!= <span class="literal">nullptr</span>&amp;&amp;cur-&gt;next-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *temp1 = cur-&gt;next;</span><br><span class="line">            ListNode *temp2 = temp1-&gt;next;</span><br><span class="line">            cur-&gt;next = temp2;</span><br><span class="line">            temp1-&gt;next = temp2-&gt;next;</span><br><span class="line">            temp2-&gt;next = temp1;</span><br><span class="line">            cur = temp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表的倒数第n个节点"><a href="#删除链表的倒数第n个节点" class="headerlink" title="删除链表的倒数第n个节点"></a>删除链表的倒数第n个节点</h3><p><strong>双指针法</strong><br>删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* second = dummyhead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(first)</span><br><span class="line">        &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyhead;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><h4 id="哈希集合解法"><a href="#哈希集合解法" class="headerlink" title="哈希集合解法"></a>哈希集合解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; visited;</span><br><span class="line">        ListNode *temp = headA;</span><br><span class="line">        <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">            visited.<span class="built_in">insert</span>(temp);</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = headB;</span><br><span class="line">        <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">count</span>(temp))&#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<ul>
<li><p>时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次。</p>
</li>
<li><p>空间复杂度：O(m)，其中 m 是链表 headA 的长度。需要使用哈希集合存储链表 headA 中的全部节点。</p>
</li>
</ul>
<h4 id="双指针解法-很妙"><a href="#双指针解法-很妙" class="headerlink" title="双指针解法(很妙)"></a>双指针解法(很妙)</h4><p><strong>思路和算法</strong></p>
<p>使用双指针的方法，可以将空间复杂度降至 O(1)。</p>
<p>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。</p>
<p>当链表 headA 和 headB 都不为空时，创建两个指针pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：</p>
<p>每步操作需要同时更新指针 pA 和 pB。</p>
<p>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。</p>
<p>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针pB 移到链表 headA 的头节点。</p>
<p>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</p>
<p><strong>证明</strong></p>
<p>下面提供双指针方法的正确性证明。考虑两种情况，第一种情况是两个链表相交，第二种情况是两个链表不相交。</p>
<p>情况一：两个链表相交</p>
<p>链表 headA 和 headB 的长度分别是 m 和 n。假设链表 headA 的不相交部分有 a 个节点，链表 headB 的不相交部分有 b 个节点，两个链表相交的部分有 c 个节点，则有 a+c=m，b+c=n。</p>
<ul>
<li><p>如果 a=b，则两个指针会同时到达两个链表相交的节点，此时返回相交的节点；</p>
</li>
<li><p>如果 a!=b，则指针pA 会遍历完链表 headA，指针 pB 会遍历完链表 headB，两个指针不会同时到达链表的尾节点，然后指针pA 移到链表 headB 的头节点，指针 pB 移到链表 headA 的头节点，然后两个指针继续移动，在指针 pA 移动了 a+c+b 次、指针 pB 移动了 b+c+a 次之后，两个指针会同时到达两个链表相交的节点，该节点也是两个指针第一次同时指向的节点，此时返回相交的节点。</p>
</li>
</ul>
<p>情况二：两个链表不相交</p>
<p>链表 headA 和 headB 的长度分别是 m 和 n。考虑当 m=n 和 m !=n 时，两个指针分别会如何移动：</p>
<ul>
<li><p>如果 m=n，则两个指针会同时到达两个链表的尾节点，然后同时变成空值 null，此时返回 null；</p>
</li>
<li><p>如果 m !=n，则由于两个链表没有公共节点，两个指针也不会同时到达两个链表的尾节点，因此两个指针都会遍历完两个链表，在指针 pA 移动了 m+n次、指针 pB 移动了 n+m 次之后，两个指针会同时变成空值 null，此时返回 null。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">NULL</span> || headB==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *pa = headA;</span><br><span class="line">        ListNode *pb = headB;</span><br><span class="line">        <span class="keyword">while</span>(pa!=pb)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pa) pa = pa-&gt;next;</span><br><span class="line">            <span class="keyword">else</span>  pa = headB;</span><br><span class="line">            <span class="keyword">if</span>(pb) pb = pb-&gt;next;</span><br><span class="line">            <span class="keyword">else</span>  pb = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><blockquote>
<p>哈希表是根据关键码的值而直接进行访问的数据结构，一般哈希表都是用来快速判断一个元素是否出现集合里。</p>
<h3 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h3><ul>
<li>数组</li>
<li>set （集合）</li>
<li>map(映射)</li>
</ul>
</blockquote>
<p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：<br><img src="/2022/07/10/006-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/set%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class title="This is an test image"><br>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>
<img src="/2022/07/10/006-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/map%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class title="This is an test image">
<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的</p>
<p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p>
<h3 id="字母异位词"><a href="#字母异位词" class="headerlink" title="字母异位词"></a>字母异位词</h3><p><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string,vector&lt;string&gt; &gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(string&amp; s:strs)&#123;</span><br><span class="line">            string temp = s;</span><br><span class="line">            <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">            mp[temp].<span class="built_in">emplace_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=mp.<span class="built_in">begin</span>();it!=mp.<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></p>
<p>普通滑动窗口：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p_len = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> s_len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(s_len&lt;p_len) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = p_len<span class="number">-1</span>;<span class="comment">//想到了滑动窗口但是一开始没想到维护字符数量</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p_judge</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span>,<span class="title">s_judge</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:p)&#123;</span><br><span class="line">            p_judge[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;right;++i)&#123;</span><br><span class="line">            s_judge[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s_len)&#123;</span><br><span class="line">            s_judge[s[right]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(s_judge==p_judge)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">            s_judge[s[left]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><strong>注意</strong><br>此处比较p_judge和s_judge不能用数组，数组比较的是地址，而不是数组中的元素，不同的数组必然不相等</p>
<p><strong>优化</strong></p>
<blockquote>
<p>在方法一的基础上，我们不再分别统计滑动窗口和字符串 p 中每种字母的数量，而是统计滑动窗口和字符串 p 中每种字母数量的差；并引入变量 differ 来记录当前窗口与字符串 p 中数量不同的字母的个数，并在滑动窗口的过程中维护它。<br>在判断滑动窗口中每种字母的数量与字符串 p 中每种字母的数量是否相同时，只需要判断 differ 是否为零即可。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p_len = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> s_len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(s_len&lt;p_len) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = p_len<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p_judge</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:p)&#123;</span><br><span class="line">            p_judge[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;right;++i)&#123;</span><br><span class="line">            p_judge[s[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p_judge[i]!=<span class="number">0</span>) diff++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s_len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p_judge[s[right]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>) diff++;</span><br><span class="line">            p_judge[s[right]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(p_judge[s[right]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>) diff--;</span><br><span class="line">            <span class="keyword">if</span>(diff==<span class="number">0</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p_judge[s[left]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>) diff++;</span><br><span class="line">            p_judge[s[left]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(p_judge[s[left]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>) diff--;</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="哈希表的灵活应用"><a href="#哈希表的灵活应用" class="headerlink" title="哈希表的灵活应用"></a>哈希表的灵活应用</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set; <span class="comment">// 存放结果</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="comment">// 发现nums2的元素 在nums_set里又出现过</span></span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(num) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a><br>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p><strong>「快乐数」</strong> 定义为：</p>
<p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。<br>如果这个过程 <strong>结果为 1</strong>，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p>
<p><strong>示例</strong></p>
<blockquote>
<p>输入：n = 19<br>输出：true<br>解释：<br>$1^2 + 9^2 = 82$<br>$8^2 + 2^2 = 68$<br>$6^2 + 8^2 = 100$<br>$1^2 + 0^2 + 0^2 = 1$</p>
</blockquote>
<p>这道题乍一看，似乎要分析一波，但由于它出现在哈希表这个专题里，那其实跟数学就没啥关系了<br>抓住题目重点：<strong>无限循环</strong><br>意思是求和的过程中，sum会重复出现，这对解题很重要</p>
<p>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; se;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        se.<span class="built_in">insert</span>(n);</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> happy = n;</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(happy)&#123;</span><br><span class="line">                <span class="type">int</span> temp = happy%<span class="number">10</span>;</span><br><span class="line">                n += (temp*temp);</span><br><span class="line">                happy /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(se.<span class="built_in">count</span>(n)==<span class="number">0</span>) se.<span class="built_in">insert</span>(n);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></p>
<p><strong>分组+哈希表</strong></p>
<p>我们可以将四个数组分成两部分，A 和 B 为一组，C 和 D 为另外一组。<br>对于 A 和 B，我们使用二重循环对它们进行遍历，得到所有 A[i]+B[j] 的值并存入哈希映射中。对于哈希映射中的每个键值对，每个键表示一种 A[i]+B[j]，对应的值为 A[i]+B[j] 出现的次数。</p>
<p>对于 C 和 D，我们同样使用二重循环对它们进行遍历。当遍历到C[k]+D[l] 时，如果 -(C[k]+D[l]) 出现在哈希映射中，那么将 -(C[k]+D[l]) 对应的值累加进答案中。</p>
<p>最终即可得到满足 A[i]+B[j]+C[k]+D[l]=0 的四元组数目</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:nums2)&#123;</span><br><span class="line">                mp[i+j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:nums4)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[<span class="number">0</span>-i-j])&#123;</span><br><span class="line">                    ans+=mp[<span class="number">0</span>-i-j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="C-C-中的字符串"><a href="#C-C-中的字符串" class="headerlink" title="C/C++中的字符串"></a>C/C++中的字符串</h3><p>在C语言中，把一个字符串存入一个数组时，也把结束符 ‘\0’存入数组，并以此作为该字符串是否结束的标志。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">5</span>] = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; a[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用’\0’来判断是否结束。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string a = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>vector&lt; char &gt; 和 string 在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string本质上可以看做是一种vector&lt; char &gt;,也就是元素为char的vector。所以有关 vector的基本操作都可以在string上进行。<br>string和vector一样，也有好几种初始化方法<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1;</span><br><span class="line"><span class="function">string <span class="title">s2</span> <span class="params">(<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s3</span> <span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s4</span> <span class="params">(s3)</span></span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>string的size()也可以用length()来代替，一般情况下使用length()只是为了更好的表明这是一个字符串而已。</li>
<li>string的连接是通过加法操作符实现的，加号两边可以随意组合string或是字符串字面量。</li>
</ul>
<p>字符串比较的三个规则：</p>
<blockquote>
<ol>
<li>字符串比较区分大小写，而大写字母比小写字母小（符合ASCLL码的顺序）。</li>
<li>字符串不等长，但是在短的字符串与长的字符串的前一部分完全相等的情况下，短的string小于长的string。</li>
<li>遇到第一对不匹配的字符就立刻返回按字典顺序比较的结果。</li>
</ol>
</blockquote>
<p><strong>int类型转为string类的方法</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 方法1</span></span><br><span class="line">    <span class="type">int</span> nNum1 = <span class="number">123</span>;</span><br><span class="line">    stringstream ss;</span><br><span class="line"> </span><br><span class="line">    ss &lt;&lt; nNum1;</span><br><span class="line">    string strTest1 = ss.<span class="built_in">str</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;strTest1 is: &quot;</span> &lt;&lt; strTest1 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    string strTest2;</span></span><br><span class="line"><span class="comment">    strTest2 &lt;&lt; ss;     // stringstream 未定义 &lt;&lt; 操作符，故此句报错</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;strTest2 is: &quot; &lt;&lt; strTest2 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    string strTest3;</span><br><span class="line">    ss &gt;&gt; strTest3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;strTest3 is: &quot;</span> &lt;&lt; strTest3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 方法2</span></span><br><span class="line">    <span class="type">int</span> nNum2 = <span class="number">456</span>;</span><br><span class="line">    string strTest4;</span><br><span class="line">    strTest4 = <span class="built_in">to_string</span>(nNum2);    <span class="comment">// C++11 标准</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;strTest4 is: &quot;</span> &lt;&lt; strTest4 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>substr</strong></p>
<blockquote>
<p>（1） substr(num);//返回从num脚标开始的所有字符，包括num角标对应的字符<br>（2） substr(a,b);//返回从a角标开始的b个字符，包括a,a+b脚标对应的字符</p>
</blockquote>
<h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></p>
<p>我的代码(不初始化会报错)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> ans[<span class="number">30003</span>]=<span class="string">&quot;&quot;</span>; <span class="comment">//记得初始化为空</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                ans[j] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                ans[j+<span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                ans[j+<span class="number">2</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                j+=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans[j] = s[i];</span><br><span class="line">                j++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>利用C++的特性<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;     <span class="comment">//字符数组</span></span><br><span class="line">        string array;   <span class="comment">//存储结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)&#123;   <span class="comment">//遍历原字符串</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                array.<span class="built_in">push_back</span>(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">                array.<span class="built_in">push_back</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                array.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                array.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>极致思路</strong><br>扩充数组+双指针<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计空格的个数</span></span><br><span class="line">        <span class="type">int</span> sOldSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩充字符串s的大小，也就是每个空格替换成&quot;%20&quot;之后的大小</span></span><br><span class="line">        s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count * <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> sNewSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 从后先前将空格替换为&quot;%20&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = sNewSize - <span class="number">1</span>, j = sOldSize - <span class="number">1</span>; j &lt; i; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                s[i] = s[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="颠倒字符串中的单词"><a href="#颠倒字符串中的单词" class="headerlink" title="颠倒字符串中的单词"></a>颠倒字符串中的单词</h3><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 颠倒字符串中的单词</a></p>
<p>进阶：如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。</p>
<p><strong>思路</strong><br>将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。</p>
<p>所以解题分三步：</p>
<blockquote>
<ol>
<li>移除多余空格</li>
<li>将整个字符串反转</li>
<li>将每个单词反转</li>
</ol>
</blockquote>
<p>例如，源字符串为：”the sky is blue “<br>移除多余空格 : “the sky is blue”<br>字符串反转：”eulb si yks eht”<br>单词反转：”blue is sky the”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeExtraSpaces</span><span class="params">(string s)</span></span>&#123;<span class="comment">//移除多余空格</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast&lt;s.<span class="built_in">size</span>() &amp;&amp; s[fast]==<span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//移除字符串最前面空格</span></span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast&gt;<span class="number">0</span> &amp;&amp; s[fast]==<span class="string">&#x27; &#x27;</span> &amp;&amp; s[fast<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s[slow++] = s[fast++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(slow<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; s[slow<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            slow--;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseString</span><span class="params">(string s)</span></span>&#123; <span class="comment">//翻转字符串</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[left],s[right]);</span><br><span class="line">            left++;right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseWord</span><span class="params">(string s)</span></span>&#123;<span class="comment">//翻转字符串中的单词</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==s.<span class="built_in">size</span>()||s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                right = i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="built_in">swap</span>(s[left],s[right]);</span><br><span class="line">                    left++;right--;</span><br><span class="line">                &#125;</span><br><span class="line">                left = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        s = <span class="built_in">removeExtraSpaces</span>(s);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">        s = <span class="built_in">reverseString</span>(s);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">        s = <span class="built_in">reverseWord</span>(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></p>
<p>提升难度：不能申请额外空间，只能在本串上操作</p>
<p><strong>思路</strong><br>和上题相似，先整体反转，再局部反转<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + n);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + n, s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>它来了它来了，提到字符串一定逃脱不了的KMP</p>
<p>需要理解几个概念：<br>前缀表<br>最长相等前后缀<br>next数组如何构建（减一版本</p>
<p>详细信息请阅读： <a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> *next, <span class="type">const</span> string&amp;s)</span></span>&#123;<span class="comment">//next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度-1</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;<span class="comment">//定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; s[i]!=s[j+<span class="number">1</span>])&#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.<span class="built_in">size</span>()== <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> next[needle.<span class="built_in">size</span>()+<span class="number">1</span>]; </span><br><span class="line">        <span class="built_in">getNext</span>(next,needle);</span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;haystack.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; haystack[i] != needle[j+<span class="number">1</span>])&#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i] == needle[j+<span class="number">1</span>])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==needle.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i-needle.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h3><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></p>
<blockquote>
<p>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</p>
</blockquote>
<p>证明过程暂略</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> *next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; s[i]!=s[j+<span class="number">1</span>])&#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j+<span class="number">1</span>])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> next[s.<span class="built_in">size</span>()+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">getNext</span>(next,s);</span><br><span class="line">        <span class="type">int</span> max_common = next[s.<span class="built_in">size</span>()<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(max_common!=<span class="number">0</span> &amp;&amp; len % (len-max_common) == <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h2><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p><a href="https://leetcode.cn/problems/3sum/">三数之和</a></p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><strong>示例</strong></p>
<blockquote>
<p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]</p>
</blockquote>
<p><strong>思路</strong><br>这题本来是在哈希专题里的，一开始胡思乱想想用pair和map来做，后来发现键和值反了，推不下去，看到双指针这个绝妙的解法。就看一半题解自己写一半，代码靴靴不同，主要是这里的去重要思考蛮多的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="comment">// printf(&quot;%d %d %d\n&quot;,i,left,right);</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[left]+nums[right] == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(left+<span class="number">1</span>&lt;nums.<span class="built_in">size</span>()&amp;&amp;right<span class="number">-1</span>&gt;<span class="number">0</span>&amp;&amp;left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>]&amp;&amp;nums[right]==nums[right<span class="number">-1</span>])&#123;</span><br><span class="line">                       left++;right--; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(left+<span class="number">1</span>&lt;nums.<span class="built_in">size</span>()&amp;&amp;right<span class="number">-1</span>&gt;<span class="number">0</span>&amp;&amp;left&lt;right&amp;&amp;(nums[left]!=nums[left+<span class="number">1</span>]||nums[right]!=nums[right<span class="number">-1</span>]))&#123;</span><br><span class="line">                       left++;right--; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ps:还有个升级版四数之和，太不容易了,步步都容易错</p>
<p><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> nums_len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums_len<span class="number">-3</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&gt;target&amp;&amp;(target&gt;=<span class="number">0</span>||nums[j]&gt;=<span class="number">0</span>)) <span class="keyword">return</span> ans;<span class="comment">//注意这里的剪枝，target可能为负数</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=j+<span class="number">1</span>;i&lt;nums_len<span class="number">-2</span>;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]&gt;target&amp;&amp;(nums[i]+nums[j]&gt;=<span class="number">0</span>||target&gt;=<span class="number">0</span>)) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; j+<span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// printf(&quot;%d %d\n&quot;,j,i);</span></span><br><span class="line">                <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="comment">// printf(&quot;%d %d %d %d\n&quot;,j,i,left,right);</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//不能直接用四个相加，会溢出</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[j]+nums[i] == target-(nums[left]+nums[right]))&#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[j], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;nums.<span class="built_in">size</span>()&amp;&amp;right<span class="number">-1</span>&gt;<span class="number">0</span>&amp;&amp;left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>]&amp;&amp;nums[right]==nums[right<span class="number">-1</span>])&#123;</span><br><span class="line">                        left++;right--; </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(left+<span class="number">1</span>&lt;nums.<span class="built_in">size</span>()&amp;&amp;right<span class="number">-1</span>&gt;<span class="number">0</span>&amp;&amp;left&lt;right&amp;&amp;(nums[left]!=nums[left+<span class="number">1</span>]||nums[right]!=nums[right<span class="number">-1</span>]))&#123;</span><br><span class="line">                        left++;right--; </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(nums[j]+nums[i]&lt;target-(nums[left]+nums[right]))&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>栈和队列是STL（C++标准库）里面的两个数据结构。</p>
<p>栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。</p>
<p>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</p>
<p>所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>
<h3 id="栈和队列的互相实现"><a href="#栈和队列的互相实现" class="headerlink" title="栈和队列的互相实现"></a>栈和队列的互相实现</h3><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></p>
<p>用两个栈来模拟队列的进出等功能<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stIn;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stOut;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        stIn.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）</span></span><br><span class="line">        <span class="keyword">if</span> (stOut.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 从stIn导入数据直到stIn为空</span></span><br><span class="line">            <span class="keyword">while</span>(!stIn.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                stOut.<span class="built_in">push</span>(stIn.<span class="built_in">top</span>());</span><br><span class="line">                stIn.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = stOut.<span class="built_in">top</span>();</span><br><span class="line">        stOut.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>(); <span class="comment">// 直接使用已有的pop函数</span></span><br><span class="line">        stOut.<span class="built_in">push</span>(res); <span class="comment">// 因为pop函数弹出了元素res，所以再添加回去</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stIn.<span class="built_in">empty</span>() &amp;&amp; stOut.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que2; <span class="comment">// 辅助队列，用来备份   其实也可以只用一个队列来实现栈，只要把队列弹出的元素重新压入队列即可</span></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que1.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123; <span class="comment">// 将que1 导入que2，但要留下最后一个元素</span></span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = que1.<span class="built_in">front</span>(); <span class="comment">// 留下的最后一个元素就是要返回的值</span></span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line">        que1 = que2;            <span class="comment">// 再将que2赋值给que1</span></span><br><span class="line">        <span class="keyword">while</span> (!que2.<span class="built_in">empty</span>()) &#123; <span class="comment">// 清空que2</span></span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h3><p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>) sk.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>) sk.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>) sk.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(sk.<span class="built_in">empty</span>() || c!=sk.<span class="built_in">top</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sk.<span class="built_in">pop</span>();</span><br><span class="line">                 <span class="comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span></span><br><span class="line">            <span class="comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sk.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sk.<span class="built_in">empty</span>() || sk.<span class="built_in">top</span>()!=c)&#123;</span><br><span class="line">                sk.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!sk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res += sk.<span class="built_in">top</span>();</span><br><span class="line">            sk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p><strong>定义</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;Type, Container, Functional&gt;;</span><br></pre></td></tr></table></figure><br>Type是要存放的数据类型</p>
<p>Container是实现底层堆的容器，必须是数组实现的容器，如vector、deque</p>
<p>Functional是比较方式/比较函数/优先级<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;Type&gt;;</span><br></pre></td></tr></table></figure><br>此时默认的容器是vector，默认的比较方式是大顶堆less<type></type></p>
<p><em>举例</em><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//大顶堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"><span class="comment">//默认大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="comment">//pair</span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; a;</span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">push</span>(d);</span><br><span class="line">a.<span class="built_in">push</span>(c);</span><br><span class="line">a.<span class="built_in">push</span>(b);</span><br><span class="line"><span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) </span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; a.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   a.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为：</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p><strong>常用函数</strong></p>
<blockquote>
<p>top()<br>pop()<br>push()<br>emplace()<br>empty()<br>size()</p>
</blockquote>
<p><strong>自定义比较方式</strong></p>
<p>当数据类型并不是基本数据类型，而是自定义的数据类型时，就不能用greater或less的比较方式了，而是需要自定义比较方式</p>
<p>在此假设数据类型是自定义的水果：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>有两种自定义比较方式的方法，如下</p>
<p><strong>1.重载运算符</strong></p>
<p>重载”&lt;”</p>
<p>若希望水果价格高为优先级高，则<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大顶堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>若希望水果价格低为优先级高<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小顶堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> price;</span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><strong>2.仿函数</strong></p>
<p>若希望水果价格高为优先级高，则若希望水果价格高为优先级高，则<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大顶堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myComparison</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(fruit f1,fruit f2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此时优先队列的定义应该如下</span></span><br><span class="line">priority_queue&lt;fruit,vector&lt;fruit&gt;,myComparison&gt; q;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">myComparison</span>&#123;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;p1,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;p2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> p1.second &gt; p2.second;<span class="comment">// 小顶堆是大于号,左大于右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;c: nums)&#123;</span><br><span class="line">            mp[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,myComparison&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;c: mp)&#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">size</span>()&gt;k)&#123;<span class="comment">// 如果堆大于了K，则队列弹出，保证小顶堆大小一直为k</span></span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;<span class="comment">//找出前K个高频元素，小顶堆先弹出的是最小的，理应倒序输出到数组，这里不介意</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 时间复杂度：O(nlogk)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(n)</span></span><br></pre></td></tr></table></figure>
<p>值得一提的是，在写快排的时候，return left&gt;right 是从大到小</p>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>C++中deque是stack和queue默认的底层实现容器，deque是可以两边扩展的，而且deque里元素并不是严格的连续分布的。</p>
<p>单调队列不是一成不变的，而是不同场景不同写法，总之要保证队列里单调递减或递增的原则，所以叫做单调队列</p>
<p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p>
<p><strong>主要思想</strong></p>
<blockquote>
<p>队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。</p>
</blockquote>
<p>本题还有其他解法，有待探索<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Myqueue</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq;<span class="comment">//双端队列来实现单调队列  （从大到小）</span></span><br><span class="line">    <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">    <span class="comment">// 同时pop之前判断队列当前是否为空。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; value==dq.<span class="built_in">front</span>())&#123;</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">        <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; value&gt;dq.<span class="built_in">back</span>())&#123;</span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span></span>&#123;<span class="comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span></span><br><span class="line">        <span class="keyword">return</span> dq.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        Myqueue mq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">            mq.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(mq.<span class="built_in">front</span>());</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            mq.<span class="built_in">pop</span>(nums[x++]);</span><br><span class="line">            mq.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(mq.<span class="built_in">front</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//时间复杂度O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度O(k)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="递归和迭代遍历"><a href="#递归和迭代遍历" class="headerlink" title="递归和迭代遍历"></a>递归和迭代遍历</h3><p>递归三要素</p>
<blockquote>
<ul>
<li>确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li>确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li>确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ul>
</blockquote>
<p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,ans);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">traversal</span>(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur || !st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">//迭代法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* cur = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></p>
<blockquote>
<p>先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 空节点不入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; <span class="comment">//迭代法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> cur_size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; layer;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cur_size;++i)&#123;</span><br><span class="line">                TreeNode* cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                layer.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left) que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right) que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(layer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans,<span class="type">int</span> depth)</span></span>&#123;<span class="comment">//递归法</span></span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>() == depth) ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        ans[depth].<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,ans,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,ans,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">traversal</span>(root,ans,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> cur_size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; layer;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cur_size;++i)&#123;</span><br><span class="line">                Node* cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                layer.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                vector&lt;Node*&gt; ch = cur-&gt;children;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> c:ch)&#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(layer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        stack&lt;Node*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            Node* cur = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            vector&lt;Node*&gt; ch = cur-&gt;children;</span><br><span class="line">            <span class="built_in">reverse</span>(ch.<span class="built_in">begin</span>(),ch.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c:ch)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(TreeNode* left,TreeNode*right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">NULL</span> &amp;&amp; right==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="literal">NULL</span> || right==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val!=right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">bool</span> ll = <span class="built_in">isSame</span>(left-&gt;left,right-&gt;right);</span><br><span class="line">            <span class="type">bool</span> rr = <span class="built_in">isSame</span>(left-&gt;right,right-&gt;left);</span><br><span class="line">            <span class="keyword">return</span> ll&amp;&amp;rr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></p>
<blockquote>
<p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。<br>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。<br>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;<span class="comment">//利用完全二叉树的性质来做</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> left_depth = <span class="number">0</span>, right_depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left)&#123;</span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            left_depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right)&#123;</span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            right_depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left_depth==right_depth)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span>&lt;&lt;left_depth) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left)+<span class="built_in">countNodes</span>(root-&gt;right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>回溯三部曲：</p>
<ul>
<li>递归函数的返回值以及参数</li>
<li>回溯终止条件</li>
<li>单层搜索的过程</li>
</ul>
<p><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==k)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;=n-(k-path.<span class="built_in">size</span>())+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtracking</span>(n,k,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></p>
<p>无剪枝写法<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> a:path)&#123;</span><br><span class="line">                sum += a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum == n) result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtracking</span>(n,k,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">         <span class="built_in">backtracking</span>(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>剪枝来啦<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放结果集</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 符合条件的结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; targetSum) &#123; <span class="comment">// 剪枝操作</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span> - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) &#123; <span class="comment">// 剪枝 </span></span><br><span class="line">            sum += i; <span class="comment">// 处理</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理</span></span><br><span class="line">            <span class="built_in">backtracking</span>(targetSum, k, sum, i + <span class="number">1</span>); <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line">            sum -= i; <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不加</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不加</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; result; <span class="comment">// 存放结果集</span></span><br><span class="line">    string path; <span class="comment">// 符合条件的结果</span></span><br><span class="line">    <span class="type">const</span> string mmp[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">    <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">    <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">    <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">    <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">    <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">    <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> a = digits[startIndex] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        string letters = mmp[a];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letters.<span class="built_in">size</span>(); i++) &#123; </span><br><span class="line">            path.<span class="built_in">push_back</span>(letters[i]); <span class="comment">// 处理</span></span><br><span class="line">            <span class="built_in">backtracking</span>(digits, startIndex + <span class="number">1</span>); <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不加</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不加</span></span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">backtracking</span>(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放结果集</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 符合条件的结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> targetSum, vector&lt;<span class="type">int</span>&gt; candidates, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; targetSum) &#123; <span class="comment">// 剪枝操作</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == targetSum)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 剪枝 </span></span><br><span class="line">            sum += candidates[i]; <span class="comment">// 处理</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]); <span class="comment">// 处理</span></span><br><span class="line">            <span class="built_in">backtracking</span>(targetSum, candidates, sum, i); <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line">            sum -= candidates[i]; <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不加</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不加</span></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(target, candidates, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result; <span class="comment">// 存放结果集</span></span><br><span class="line">    vector&lt;string&gt; path; <span class="comment">// 符合条件的结果</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start]!=s[end])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string s, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 剪枝 </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isPalindrome</span>(s, startIndex, i))&#123;</span><br><span class="line">                string temp = s.<span class="built_in">substr</span>(startIndex, i-startIndex+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">push_back</span>(temp); <span class="comment">// 处理</span></span><br><span class="line">                <span class="built_in">backtracking</span>(s, i+<span class="number">1</span>); <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line">                path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不加</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不加</span></span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></p>
<p>写的很挫很挫，中途一个等于号没加还卡了半天，所幸是过了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; result; <span class="comment">// 存放结果集</span></span><br><span class="line">    string path; <span class="comment">// 符合条件的结果</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">stringToint</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            sum = sum*<span class="number">10</span> + (s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string s, <span class="type">int</span> startIndex, <span class="type">int</span> part)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;path&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (part==<span class="number">4</span> &amp;&amp; path.<span class="built_in">size</span>()==s.<span class="built_in">size</span>()+<span class="number">3</span>)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(part &gt;= <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            string temp = s.<span class="built_in">substr</span>(startIndex, i-startIndex+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(temp.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; temp[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp.<span class="built_in">size</span>()&lt;=<span class="number">3</span> &amp;&amp; <span class="built_in">stringToint</span>(temp)&lt;=<span class="number">255</span>)&#123;</span><br><span class="line">                string save_path = path;</span><br><span class="line">                path = path + temp; <span class="comment">// 处理</span></span><br><span class="line">                <span class="keyword">if</span>(part&lt;<span class="number">3</span>)&#123;</span><br><span class="line">                    path = path + <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">backtracking</span>(s, i+<span class="number">1</span>, part+<span class="number">1</span>); <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line">                path = save_path; <span class="comment">// 回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不加</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不加</span></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>()&lt;<span class="number">4</span> || s.<span class="built_in">length</span>()&gt;<span class="number">12</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></p>
<p>豁然开朗之后轻轻松松拿下<br><img src="/2022/07/10/006-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%90%E9%9B%86.png" class title="This is an test image"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt;= nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></p>
<p>和上题唯一的区别是，集合中有重复的元素，就需要考虑剪枝的问题<br>肯定先对数组排个序，然后通过判断相邻元素是否相同来进行剪枝<br>关键问题就是在哪里剪枝<br>思考了蛮久还画了个图终于剪出来了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="comment">// if(startIndex &gt;0 &amp;&amp; nums[startIndex]==nums[startIndex-1]) return;</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt;= nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="comment">// if(startIndex &gt;0 &amp;&amp; nums[startIndex]==nums[startIndex-1]) continue;</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span>&lt;nums.<span class="built_in">size</span>() &amp;&amp; nums[i+<span class="number">1</span>]==nums[i]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/increasing-subsequences/">491. 递增子序列</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex, <span class="type">int</span> cur_path_idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt;= nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; uset;<span class="comment">//同一父节点下的同层上使用过的元素就不能在使用了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (uset.<span class="built_in">find</span>(nums[i]) != uset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur_path_idx==<span class="number">-1</span> || nums[i]&gt;=path[cur_path_idx])&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                uset.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">                <span class="comment">// cur_path_idx++;</span></span><br><span class="line">                <span class="built_in">backtracking</span>(nums,i+<span class="number">1</span>,cur_path_idx+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> n,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==n)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[index],nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,n,index+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(nums[index],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> n,vector&lt;<span class="type">bool</span>&gt; &amp;used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==n)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,n,used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,nums.<span class="built_in">size</span>(),used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a><br>和上题基本一样，不过数组中含重复元素<br>添加两行代码去重就okk啦（已经基本掌握去重小技巧（排序+跳跃<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> n,vector&lt;<span class="type">bool</span>&gt; &amp;used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==n)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,n,used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span>&lt;n&amp;&amp;nums[i+<span class="number">1</span>]==nums[i]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,nums.<span class="built_in">size</span>(),used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> row,vector&lt;string&gt; &amp;chessboard)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(chessboard);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>;col&lt;n;col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(row,col,chessboard,n))&#123;</span><br><span class="line">                chessboard[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">backtracking</span>(n,row+<span class="number">1</span>,chessboard);</span><br><span class="line">                chessboard[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;string&gt;&amp;chessboard, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][col]==<span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// 检查 45度角是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查 135度角是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">std::vector&lt;std::string&gt; <span class="title">chessboard</span><span class="params">(n, std::string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(n,<span class="number">0</span>,chessboard);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a><br>困难题果然名不虚传，就写对了一个isValid函数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++) &#123;        <span class="comment">// 遍历行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 遍历列</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> k = <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++) &#123;     <span class="comment">// (i, j) 这个位置放k是否合适</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isValid</span>(i, j, k, board)) &#123;</span><br><span class="line">                    board[i][j] = k;                <span class="comment">// 放置k</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">backtracking</span>(board)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果找到合适一组立刻返回</span></span><br><span class="line">                    board[i][j] = <span class="string">&#x27;.&#x27;</span>;              <span class="comment">// 回溯，撤销k</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">// 9个数都试完了，都不行，那么就返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span> val, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123; <span class="comment">// 判断行里是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][i] == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123; <span class="comment">// 判断列里是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (board[j][col] == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> startRow = (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> startCol = (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startRow; i &lt; startRow + <span class="number">3</span>; i++) &#123; <span class="comment">// 判断9方格里是否重复</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = startCol; j &lt; startCol + <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == val ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></p>
<p>看正规解题思路前的初尝试，也算是动态规划搞出来了吧<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//要警惕数组相等的情况</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">1</span>]!=nums[<span class="number">0</span>]) dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (nums[i]-nums[i<span class="number">-1</span>])*(nums[i<span class="number">-1</span>]-nums[i<span class="number">-2</span>]) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> j = i<span class="number">-2</span>;</span><br><span class="line">                <span class="keyword">for</span>(;j&gt;<span class="number">0</span>;--j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((nums[i]-nums[j])*(nums[j]-nums[j<span class="number">-1</span>]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]!=nums[j]) dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[j]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><strong>贪心思路</strong><br>题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> prediff = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curdiff = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            curdiff = nums[i]-nums[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>( (curdiff&gt;<span class="number">0</span>&amp;&amp;prediff&lt;=<span class="number">0</span>) || (prediff&gt;=<span class="number">0</span>&amp;&amp;curdiff&lt;<span class="number">0</span>) )&#123;</span><br><span class="line">                res ++;</span><br><span class="line">                prediff = curdiff;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><p><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a><br>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> cover = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=cover;++i)&#123;<span class="comment">//关键是当前最远只能到cover</span></span><br><span class="line">            cover = <span class="built_in">max</span>(i+nums[i],cover);</span><br><span class="line">            <span class="keyword">if</span>(cover&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></p>
<p>我又只会写最挫的代码，还要思考好久,得亏数据量不大，不然必超时<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cover = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">step</span><span class="params">(nums.size()+<span class="number">1</span>,INT_MAX)</span></span>;<span class="comment">//记录到每一步的最小跳跃次数</span></span><br><span class="line">        step[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;<span class="comment">//因为题目保证一定能到终点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=i+nums[i];++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    step[j] = <span class="built_in">min</span>(step[j],step[i]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>高效思路：以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数！<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curDistance = <span class="number">0</span>;    <span class="comment">// 当前覆盖最远距离下标</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;            <span class="comment">// 记录走的最大步数</span></span><br><span class="line">        <span class="type">int</span> nextDistance = <span class="number">0</span>;   <span class="comment">// 下一步覆盖最远距离下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            nextDistance = <span class="built_in">max</span>(nums[i] + i, nextDistance);  <span class="comment">// 更新下一步覆盖最远距离下标</span></span><br><span class="line">            <span class="keyword">if</span> (i == curDistance) &#123;                         <span class="comment">// 遇到当前覆盖最远距离下标</span></span><br><span class="line">                <span class="keyword">if</span> (curDistance != nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;       <span class="comment">// 如果当前覆盖最远距离下标不是终点</span></span><br><span class="line">                    ans++;                                  <span class="comment">// 需要走下一步</span></span><br><span class="line">                    curDistance = nextDistance;             <span class="comment">// 更新当前覆盖最远距离下标（相当于加油了）</span></span><br><span class="line">                    <span class="keyword">if</span> (nextDistance &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 下一步的覆盖范围已经可以达到终点，结束循环</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">break</span>;                               <span class="comment">// 当前覆盖最远距离下标是集合终点，不用做ans++操作了，直接结束</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></p>
<p>这题思路蛮简单的，但是我自己做的时候会意识不到这用到了贪心的思路</p>
<p>并且，最优的思路应按绝对值大小从大到小排序</p>
<p>上标准代码</p>
<ul>
<li>第一步：将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小</li>
<li>第二步：从前向后遍历，遇到负数将其变为正数，同时K—</li>
<li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</li>
<li>第四步：求和<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a) &gt; <span class="built_in">abs</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), cmp);       <span class="comment">// 第一步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 第二步</span></span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span> &amp;&amp; K &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                A[i] *= <span class="number">-1</span>;</span><br><span class="line">                K--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (K % <span class="number">2</span> == <span class="number">1</span>) A[A.<span class="built_in">size</span>() - <span class="number">1</span>] *= <span class="number">-1</span>; <span class="comment">// 第三步</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : A) result += a;        <span class="comment">// 第四步</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;   <span class="comment">// 当前累加rest[i]和 curSum一旦小于0</span></span><br><span class="line">                start = i + <span class="number">1</span>;  <span class="comment">// 起始位置更新为i+1</span></span><br><span class="line">                curSum = <span class="number">0</span>;     <span class="comment">// curSum从0开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 说明怎么走都不可能跑一圈了</span></span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a><br>我们可以将「相邻的孩子中，评分高的孩子必须获得更多的糖果」这句话拆分为两个规则，分别处理。</p>
<p>左规则：当 ratings[i - 1] &lt; ratings[i]时，i 号学生的糖果数量将比 i - 1 号孩子的糖果数量多。</p>
<p>右规则：当 ratings[i]&gt;ratings[i+1] 时，i 号学生的糖果数量将比 i+1 号孩子的糖果数量多。</p>
<p>注意两次遍历方向需要不同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(ratings.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ratings.<span class="built_in">size</span>()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i+<span class="number">1</span>]&gt;ratings[i])&#123;</span><br><span class="line">                a[i+<span class="number">1</span>] = a[i]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=ratings.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i<span class="number">-1</span>]&gt;ratings[i])&#123;</span><br><span class="line">                a[i<span class="number">-1</span>] = <span class="built_in">max</span>(a[i<span class="number">-1</span>],a[i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:a)&#123;</span><br><span class="line">            ans+=i;</span><br><span class="line">            <span class="comment">// printf(&quot;%d &quot;,i);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></p>
<blockquote>
<p>如果两个维度一起考虑一定会顾此失彼。<br>按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。<br>此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高<br>那么只需要按照k为下标重新插入队列就可以了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;a, vector&lt;<span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;people.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>()+people[i][<span class="number">1</span>],people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="重叠区间问题"><a href="#重叠区间问题" class="headerlink" title="重叠区间问题"></a>重叠区间问题</h3><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></p>
<p>超时写法来了……<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">// static bool cmp(vector&lt;int&gt; a,vector&lt;int&gt;b)&#123;</span></span><br><span class="line"><span class="comment">//     if(a[0]==b[0]) return a[1]&lt;b[1];</span></span><br><span class="line"><span class="comment">//     return a[0]&lt;b[0];</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a,vector&lt;<span class="type">int</span>&gt;b)</span></span>&#123;</span><br><span class="line">    <span class="comment">// if(a[1]==b[1]) return a[0]&lt;b[0];</span></span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(),points.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> arrows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;points.<span class="built_in">size</span>();)&#123;</span><br><span class="line">            <span class="type">int</span> tail = points[i][<span class="number">1</span>];</span><br><span class="line">            arrows++;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;points.<span class="built_in">size</span>() &amp;&amp; tail&gt;=points[i][<span class="number">0</span>])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto &amp;c:points)&#123;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;&quot;[&quot;;</span></span><br><span class="line">        <span class="comment">//     for(auto &amp;i:c)&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;&quot;]&quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> arrows;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>研究了半天，好像找到了我超时的原因了……<br>是因为写cmp的时候，比较数组a和b前面没有加&amp;<br>以下是正确代码，两个代码的主体思路都对，只是上面代码cmp写挫了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(),points.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="type">int</span> arrows = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tail = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tail&lt;points[i][<span class="number">0</span>])&#123;</span><br><span class="line">                tail = points[i][<span class="number">1</span>];</span><br><span class="line">                arrows++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrows;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>tips：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>&#123;  </span><br><span class="line"><span class="number">2</span>     <span class="keyword">return</span> a&gt;b;  </span><br><span class="line"><span class="number">3</span> &#125;  </span><br><span class="line"><span class="number">4</span>  </span><br><span class="line"><span class="number">5</span> <span class="type">int</span> a[<span class="number">10</span>];  </span><br><span class="line"><span class="number">6</span> <span class="built_in">sort</span>(a,a+<span class="number">10</span>,cmp); </span><br></pre></td></tr></table></figure><br><strong>思考：</strong><br>int 和const int&amp;有什么区别呢？<br>原来：作为函数参数：int这种写法是值传递，const int&amp;则是引用传递。<br>“值传递”——由于函数将自动产生临时变量用于复制该参数，效率较低。<br>“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。效率较高。<br>而“引用传递”有可能改变参数,const修饰可以解决这个问题。</p>
<p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a><br>思路：先对区间按照左边排序，然后判断当前区间和上一个区间右边界的关系，如果当前区间的左边界大于上一个右边界border，则意味着当前区间和上一个区间是无重叠区间，计数+1，若当前区间的左边界小于border，意味着两个区间有重叠，则判断哪个右边界更小，若当前右边界更小，意味着可以容纳更多的无重叠区间，更新border<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="type">int</span> nonOverlap = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> border = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&gt;=border)&#123;</span><br><span class="line">                nonOverlap++;</span><br><span class="line">                border = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;border&amp;&amp;intervals[i][<span class="number">1</span>]&gt;=border)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                border = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n-nonOverlap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a><br>受前两题启发，分析完这题，觉得这不就是先统计每个字符第一次出现的位置和最后一次出现的位置，然后求最多的不重合子区间嘛？<br>思路其实算是对的，但是分析完思路之后也没尝试去简化思路，导致代码写的又长又挫</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp;a,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ve;</span><br><span class="line">        <span class="type">int</span> start[<span class="number">26</span>],end[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">            start[i] = <span class="number">-1</span>;</span><br><span class="line">            end[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(start[s[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">-1</span>)&#123;</span><br><span class="line">                start[s[i]-<span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end[s[j]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">-1</span>)&#123;</span><br><span class="line">                end[s[j]-<span class="string">&#x27;a&#x27;</span>] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">            <span class="keyword">if</span>(start[i]!=<span class="number">-1</span>&amp;&amp;end[i]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(start[i]);</span><br><span class="line">                temp.<span class="built_in">push_back</span>(end[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(start[i]==<span class="number">-1</span>&amp;&amp;end[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(start[i]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(start[i]);</span><br><span class="line">                temp.<span class="built_in">push_back</span>(start[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(end[i]);</span><br><span class="line">                temp.<span class="built_in">push_back</span>(end[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            ve.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ve.<span class="built_in">begin</span>(),ve.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="comment">// for(auto&amp; t:ve)&#123;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;&quot;[&quot;;</span></span><br><span class="line">        <span class="comment">//     for(auto&amp; c:t)&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;c&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;&quot;]&quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> border = ve[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;ve.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ve[i][<span class="number">0</span>]&gt;border)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(border);</span><br><span class="line">                border = ve[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ve[i][<span class="number">1</span>]&gt;border)&#123;</span><br><span class="line">                border = ve[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(border);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=ans.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">            ans[i] = ans[i]-ans[i<span class="number">-1</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>] = ans[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更简洁点的思路应该是：只需要记录每个字符最后出现的位置，然后在遍历字符串的过程中，比较当前字符最后出现的位置是否晚于前面字符的最后位置，如果是则更新，达到此位置时，完成字母区间切分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">27</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// i为字符，hash[i]为字符出现的最后位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 统计每一个字符最后出现的位置</span></span><br><span class="line">            hash[S[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            right = <span class="built_in">max</span>(right, hash[S[i] - <span class="string">&#x27;a&#x27;</span>]); <span class="comment">// 找到字符出现的最远边界</span></span><br><span class="line">            <span class="keyword">if</span> (i == right) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(right - left + <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></p>
<p>精髓：当我们卖出一支股票时，我们就立即获得了以相同价格并且免除手续费买入一支股票的权利</p>
<p>设定初始最小值为prices[0]，即第0天的股票价格，遍历中会遇到两种情况：</p>
<ul>
<li>当前价格小于min_price,则更新min_price</li>
<li>当前价格大于min_price+手续费 ，则可以考虑以当前价格卖出股票，但需要注意的是，此时卖出股票可能并不是全局最优的（例如下一天股票价格继续上升），因此我们可以提供一个反悔操作，看成当前手上拥有一支买入价格为prices[i]-手续费 的股票，这样一来，如果下一天股票价格继续上升，我们会获得prices[i+1]−prices[i]的收益，恰好就等于在这一天不进行任何操作，而在下一天卖出股票的收益</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min_price = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(min_price&gt;prices[i])&#123;</span><br><span class="line">                min_price = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(prices[i]-min_price&gt;fee)&#123;</span><br><span class="line">                ans += prices[i]-min_price-fee;</span><br><span class="line">                min_price = prices[i]-fee;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></p>
<p>dp[i]含义：分拆数字i，可以得到的最大乘积为dp[i]</p>
<p>递归公式： $dp[i] = max(dp[i], max((i - j) <em> j, dp[i - j] </em> j))$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;++j)&#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],(i-j)*j);</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],dp[i-j]*j); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></p>
<p>推了半天没推出精髓-_-</p>
<blockquote>
<p>举例，dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量<br>元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 <em> 左子树有0个元素的搜索树数量<br>元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 </em> 左子树有1个元素的搜索树数量<br>元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 <em> 左子树有2个元素的搜索树数量<br>有2个元素的搜索树数量就是dp[2]。<br>有1个元素的搜索树数量就是dp[1]。<br>有0个元素的搜索树数量就是dp[0]。<br>所以dp[3] = dp[2] </em> dp[0] + dp[1] <em> dp[1] + dp[0] </em> dp[2]</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                dp[i] += dp[j]*dp[i-j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>逃不过的背包问题它来啦</p>
<h5 id="二维背包"><a href="#二维背包" class="headerlink" title="二维背包"></a>二维背包</h5><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></p>
<p>刚开始做背包，还不太熟练，这题的关键在于weight[i]和value[i]都是nums[i]<br>（熟悉了咱再去用一维滚动数组）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a:nums)&#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum = sum / <span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(sum+<span class="number">1</span>,<span class="number">0</span>) );</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = nums[<span class="number">0</span>];j&lt;=sum;++j)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=sum;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;nums[i]) dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-nums[i]]+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>][sum]==sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="一维滚动背包"><a href="#一维滚动背包" class="headerlink" title="一维滚动背包"></a>一维滚动背包</h5><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></p>
<p>蛮刁钻的角度</p>
<p>思路：题意视作把这堆石头分成两堆，求两堆石头的最小重量差异</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a: stones)&#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> goal = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(goal+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;stones.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=goal; j&gt;=stones[i]; --j)&#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-stones[i]]+stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum-dp[goal]-dp[goal];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><h3 id="广度优先搜索、深度优先搜索"><a href="#广度优先搜索、深度优先搜索" class="headerlink" title="广度优先搜索、深度优先搜索"></a>广度优先搜索、深度优先搜索</h3>]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>CPP</tag>
        <tag>Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>经验教训&amp;&amp;遇到的Bug们</title>
    <url>/2021/03/09/008-%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/</url>
    <content><![CDATA[<h2 id="安装mmcv和mmseg"><a href="#安装mmcv和mmseg" class="headerlink" title="安装mmcv和mmseg"></a>安装mmcv和mmseg</h2><h3 id="安装mmcv"><a href="#安装mmcv" class="headerlink" title="安装mmcv"></a>安装mmcv</h3><p>源码地址：<br><a href="https://github.com/open-mmlab/mmcv">https://github.com/open-mmlab/mmcv</a><br>对应表格确认自己环境的pytorch版本和cuda版本<br>按照指定命令安装<br>注意！！！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install mmcv-full==&#123;mmcv_version&#125; -f https://download.openmmlab.com/mmcv/dist/&#123;cu_version&#125;/&#123;torch_version&#125;/index.html</span><br></pre></td></tr></table></figure>
<p>其中的{mmcv_version}要替换为具体的版本号<br>如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install mmcv-full==<span class="number">1.3</span><span class="number">.9</span> -f https://download.openmmlab.com/mmcv/dist/cu111/torch1<span class="number">.9</span><span class="number">.0</span>/index.html</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/e98242f8462a4c6d941f4b697d8ba980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="安装mmseg"><a href="#安装mmseg" class="headerlink" title="安装mmseg"></a>安装mmseg</h3><p>虽然代码中用的是import mmseg<br>但是安装的时候mmseg要写全<br>命令为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install mmsegmentation</span><br></pre></td></tr></table></figure>
<p>&nbsp;   <!-- 空行 --></p>
<p><strong>PS：</strong> 这篇当时发在CSDN，后来有人给我评论感谢我，嘿嘿嘿<br><img src="/2021/03/09/008-%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/mmcv.png" class title="This is an test image"></p>
<h2 id="TypeError-’builtin-function-or-method’-object-has-no-attribute-‘getitem’"><a href="#TypeError-’builtin-function-or-method’-object-has-no-attribute-‘getitem’" class="headerlink" title="TypeError:’builtin_function_or method’ object has no attribute ‘getitem’"></a>TypeError:’builtin_function_or method’ object has no attribute ‘getitem’</h2><h3 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h3><font color="#999AAA">提示：内置函数或方法对象没有获取项目属性
可能是内置的函数中符号写错，比如range(1,5)写成range[1,5]</font>



<h2 id="except-more-than-1-value-per-channel-when-training，got-input-size……"><a href="#except-more-than-1-value-per-channel-when-training，got-input-size……" class="headerlink" title="except more than 1 value per channel when training，got input size……"></a>except more than 1 value per channel when training，got input size……</h2><p> &lt;/font&gt;</p>
<h3 id="原因分析：-1"><a href="#原因分析：-1" class="headerlink" title="原因分析："></a>原因分析：</h3><font color="#999AAA">当batch里只有一个样本时，调用batch_norm就会报错（bn层需要大于一个样本去计算其中的参数，需要多于一个数据计算平均值）
比如dataset的总样本数为17，而batch_size为8，就会报错</font>


<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ul>
<li><p>在训练前用num_of_samples%batch_size算一下会不会正好剩下一个样本</p>
</li>
<li><p>将dataloader的丢弃参数设置为true，drop_last=True</p>
</li>
</ul>
<h2 id="训练时出现nan"><a href="#训练时出现nan" class="headerlink" title="训练时出现nan"></a>训练时出现nan</h2><h3 id="原因分析：-2"><a href="#原因分析：-2" class="headerlink" title="原因分析："></a>原因分析：</h3><font color="#999AAA">梯度爆炸，调小学习率，加BN，梯度裁剪；损失函数或网络设计，出现除0</font>



<h2 id="Error-running’train’-Unknown-error-4-minutes-ago"><a href="#Error-running’train’-Unknown-error-4-minutes-ago" class="headerlink" title="Error running’train’:Unknown error(4 minutes ago)"></a>Error running’train’:Unknown error(4 minutes ago)</h2><p>waiting for process detach—————————————<br>运行界面无任何东西<br>且run界面经常几个程序的结果图片拼凑在一起</p>
<p>网上同样问题： <a href="https://stackoverflow.com/questions/67209905/why-keep-getting-the-same-error-in-pycharm-error-running-unknown-error">https://stackoverflow.com/questions/67209905/why-keep-getting-the-same-error-in-pycharm-error-running-unknown-error</a><br> &lt;/font&gt;</p>
<h3 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h3><p>1、工具栏——Run——Edit Configurations</p>
<p>2、删除出问题的项目路径：</p>
<p>3、保存后，重新运行项目，就正常了。</p>
<h2 id="RuntimeError-cuDNN-error-CUDNN-STATUS-NOT-INITIALIZED"><a href="#RuntimeError-cuDNN-error-CUDNN-STATUS-NOT-INITIALIZED" class="headerlink" title="RuntimeError: cuDNN error: CUDNN_STATUS_NOT_INITIALIZED"></a>RuntimeError: cuDNN error: CUDNN_STATUS_NOT_INITIALIZED</h2><h3 id="原因分析：-3"><a href="#原因分析：-3" class="headerlink" title="原因分析："></a>原因分析：</h3><font color="#999AAA">1、第一个办法就是重启大法；
2、查看cuda版本与cudnn版本是否匹配；
3、查看pytorch版本是否与显卡匹配，不知道是否匹配，就试试，或许降低版本会有意料之外的效果，即解决了；
4、看驱动版本是否与cuda匹配；</font>

<h3 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a>解决方案：</h3><p>1、删掉重装<br>pip install torch==1.8.0+cu111 torchvision==0.9.0+cu111 torchaudio==0.8.0 -f <a href="https://download.pytorch.org/whl/torch_stable.html">https://download.pytorch.org/whl/torch_stable.html</a><br>cpu/torch-0.3.0.post4-cp27-cp27m-linux_x86_64.whl cpu/torch-0.3.0.post4-cp27-cp27mu-linux_x86_64.whl</p>
<h2 id="Pycharm-Can’t-get-remote-credentials-for-deployment-server"><a href="#Pycharm-Can’t-get-remote-credentials-for-deployment-server" class="headerlink" title="Pycharm:Can’t get remote credentials for deployment server"></a>Pycharm:Can’t get remote credentials for deployment server</h2><p>在使用pycharm的过程中，在Path mappings栏，无法点击右边的按钮<br>但是在deployment中，是确定已经连接上服务器的，而且Run&gt;Edit configuration中，Python interpreter也是远程服务器上的解释器.<br> &lt;/font&gt;</p>
<h3 id="原因分析：-4"><a href="#原因分析：-4" class="headerlink" title="原因分析："></a>原因分析：</h3><h3 id="解决方案：-3"><a href="#解决方案：-3" class="headerlink" title="解决方案："></a>解决方案：</h3><p>把图片上显示的Python interpreter删除，然后重新设置，然后就可以正常使用了。</p>
<h2 id="RuntimeError-CUDA-error-out-of-memory"><a href="#RuntimeError-CUDA-error-out-of-memory" class="headerlink" title="RuntimeError:CUDA error:out of memory"></a>RuntimeError:CUDA error:out of memory</h2><h3 id="原因分析：-5"><a href="#原因分析：-5" class="headerlink" title="原因分析："></a>原因分析：</h3><p>可能是tensorflow和pytorch版本冲突导致的，需要让pytorch能看到服务器上所有gpu<br><img src="https://img-blog.csdnimg.cn/20210707215310620.png" alt="在这里插入图片描述"></p>
<p>正常的out of memory是<br>RuntimeError: CUDA out of memory. Tried to allocate 1.27 GiB (GPU 0; 11.75 GiB total capacity; 10.14 GiB already allocated; 543.75 MiB free; 18.10 MiB cached)</p>
<h3 id="解决方案：-4"><a href="#解决方案：-4" class="headerlink" title="解决方案："></a>解决方案：</h3><p>链接：  <a href="https://github.com/pytorch/pytorch/issues/20990">https://github.com/pytorch/pytorch/issues/20990</a></p>
<p>在代码前面加上：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.cuda.current_device()</span><br><span class="line">torch.cuda._initialized = <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<h2 id="IndexError-tuple-index-out-of-range"><a href="#IndexError-tuple-index-out-of-range" class="headerlink" title="IndexError: tuple index out of range"></a>IndexError: tuple index out of range</h2><p>File “/storage/node3/hyy/anaconda3/lib/python3.6/site-packages/torchsummary/torchsummary.py”, line 19, in hook<br>    summary[m_key][“input_shape”] = list(input[0].size())</p>
<p>RuntimeError: cuda runtime error (710) : device-side assert triggered at /pytorch/aten/src/THCUNN/generic/SpatialClassNLLCriterion.cu:134</p>
<h3 id="原因分析：-6"><a href="#原因分析：-6" class="headerlink" title="原因分析："></a>原因分析：</h3><p>a = torch.randn(10)<br>a[11]<br>这里的11超过了a的范围</p>
<h2 id="RuntimeError-cuda-runtime-error-710-device-side-assert-triggered-at-pytorch-aten-src-THCUNN-generic-SpatialClassNLLCriterion-cu-134"><a href="#RuntimeError-cuda-runtime-error-710-device-side-assert-triggered-at-pytorch-aten-src-THCUNN-generic-SpatialClassNLLCriterion-cu-134" class="headerlink" title="RuntimeError: cuda runtime error (710) : device-side assert triggered at /pytorch/aten/src/THCUNN/generic/SpatialClassNLLCriterion.cu:134"></a>RuntimeError: cuda runtime error (710) : device-side assert triggered at /pytorch/aten/src/THCUNN/generic/SpatialClassNLLCriterion.cu:134</h2><h3 id="原因分析：-7"><a href="#原因分析：-7" class="headerlink" title="原因分析："></a>原因分析：</h3><ol>
<li>计算loss前没有sigmoid或者softmax</li>
<li>label标签为负值或者大于类别数，专业解释：训练过程中存在超出分类数目的标签，索引异常<br>因为标签要满足t &gt;= 0 &amp;&amp; t &lt; n_classes。而我的不是因为出现-1标签，是因为超出了类别数的范围</li>
<li>输出的通道数不对（PraNet）</li>
</ol>
<h3 id="解决方案：-5"><a href="#解决方案：-5" class="headerlink" title="解决方案："></a>解决方案：</h3><p>1.PraNet的深度监督每个输出前加个卷积使其变成三通道</p>
<h2 id="RuntimeError-DataLoader-worker-pid-644988-is-killed-by-signal-Segmentation-fault"><a href="#RuntimeError-DataLoader-worker-pid-644988-is-killed-by-signal-Segmentation-fault" class="headerlink" title="RuntimeError: DataLoader worker (pid 644988) is killed by signal: Segmentation fault."></a>RuntimeError: DataLoader worker (pid 644988) is killed by signal: Segmentation fault.</h2><h3 id="原因分析：-8"><a href="#原因分析：-8" class="headerlink" title="原因分析："></a>原因分析：</h3><p>数据加载过程中内存被耗尽</p>
<p>可通过减少dataloader的num_worker或增加虚拟内存解决。</p>
<h3 id="解决方案：-6"><a href="#解决方案：-6" class="headerlink" title="解决方案："></a>解决方案：</h3><h2 id="Pycharm报错：Process-finished-with-exit-code-134-interrupted-by-signal-6-SIGABRT"><a href="#Pycharm报错：Process-finished-with-exit-code-134-interrupted-by-signal-6-SIGABRT" class="headerlink" title="Pycharm报错：Process finished with exit code 134 (interrupted by signal 6: SIGABRT)"></a>Pycharm报错：Process finished with exit code 134 (interrupted by signal 6: SIGABRT)</h2><h3 id="原因分析：-9"><a href="#原因分析：-9" class="headerlink" title="原因分析："></a>原因分析：</h3><h3 id="解决方案：-7"><a href="#解决方案：-7" class="headerlink" title="解决方案："></a>解决方案：</h3><p><a href="https://blog.csdn.net/m0_43505377/article/details/103945714">https://blog.csdn.net/m0_43505377/article/details/103945714</a></p>
<p><a href="https://blog.csdn.net/jizhidexiaoming/article/details/80918868">https://blog.csdn.net/jizhidexiaoming/article/details/80918868</a></p>
<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;</p>
<h2 id="RuntimeError-cuDNN-error-CUDNN-STATUS-NOT-INITIALIZED-1"><a href="#RuntimeError-cuDNN-error-CUDNN-STATUS-NOT-INITIALIZED-1" class="headerlink" title="RuntimeError: cuDNN error: CUDNN_STATUS_NOT_INITIALIZED"></a>RuntimeError: cuDNN error: CUDNN_STATUS_NOT_INITIALIZED</h2><h3 id="原因分析：-10"><a href="#原因分析：-10" class="headerlink" title="原因分析："></a>原因分析：</h3><p>GPU算力不足</p>
<h2 id="Host-key-verification-failed"><a href="#Host-key-verification-failed" class="headerlink" title="Host key verification failed."></a>Host key verification failed.</h2><h3 id="原因分析：-11"><a href="#原因分析：-11" class="headerlink" title="原因分析："></a>原因分析：</h3><p>这个问题，是你重置过你的服务器后。你再次想访问会出现这个问题。</p>
<h3 id="解决方案：-8"><a href="#解决方案：-8" class="headerlink" title="解决方案："></a>解决方案：</h3><p>ssh-keygen -R 你要访问的IP地址<br>比如：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh-keygen -R  <span class="number">172.21</span><span class="number">.144</span><span class="number">.46</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>经验记录</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>Python&amp;&amp;Pytorch笔记</title>
    <url>/2021/08/04/009-Python-Pytorch%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong> 前言 </strong></p>
<font color="#999AAA">
写代码看代码遇到的问题</font>

<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="map-and-lambda"><a href="#map-and-lambda" class="headerlink" title="map and lambda"></a>map and lambda</h2><p><strong>描述</strong><br>map() 会根据提供的函数对指定序列做映射。</p>
<p>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p>
<p><strong>语法</strong><br>map() 函数语法：</p>
<p>map(function, iterable, …)<br><strong>参数</strong></p>
<ul>
<li>function — 函数</li>
<li>iterable — 一个或多个序列</li>
</ul>
<p><strong>返回值</strong><br>Python 2.x 返回列表。<br>Python 3.x 返回迭代器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>) :            <span class="comment"># 计算平方数</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(square, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])   <span class="comment"># 计算列表各个元素的平方</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])  <span class="comment"># 使用 lambda 匿名函数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="comment"># 提供了两个列表，对相同位置的列表数据进行相加</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line">[<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure>
<p><strong>lambda表达式是一行函数。</strong><br>它们在其他语言中也被称为匿名函数。如果你不想在程序中对一个函数使用两次，你也许会想用lambda表达式，它们和普通的函数完全一样。</p>
<p><strong>原型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 参数:操作(参数)</span><br></pre></td></tr></table></figure>
<p><strong>例子</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># Output: 8</span></span><br></pre></td></tr></table></figure></p>
<p>这还有一些lambda表达式的应用案例，可以在一些特殊情况下使用：</p>
<p><strong>列表排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">9</span>, <span class="number">10</span>), (<span class="number">13</span>, -<span class="number">3</span>)]</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># Output: [(13, -3), (4, 1), (1, 2), (9, 10)]</span></span><br></pre></td></tr></table></figure>
<p><strong>列表并行排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="built_in">zip</span>(list1, list2)</span><br><span class="line">data = <span class="built_in">sorted</span>(data)</span><br><span class="line">list1, list2 = <span class="built_in">map</span>(<span class="keyword">lambda</span> t: <span class="built_in">list</span>(t), <span class="built_in">zip</span>(*data))</span><br></pre></td></tr></table></figure>
<h2 id="nonzero"><a href="#nonzero" class="headerlink" title="nonzero()"></a>nonzero()</h2><p>用于得到numpy数组中非零元素的位置（数组索引）的函数</p>
<p>返回值是一个长度为a.ndim数组a的轴数的元组，元组的每个元素都是一个整数数组，其值为非零元素的下标在对应轴上的值</p>
<h2 id="setattr"><a href="#setattr" class="headerlink" title="setattr()"></a>setattr()</h2><p>setattr() 函数指定对象的指定属性的值。<br>改变 “person” 对象的 “age” 属性的值：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">  name = <span class="string">&quot;John&quot;</span></span><br><span class="line">  age = <span class="number">36</span></span><br><span class="line">  country = <span class="string">&quot;Norway&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setattr</span>(Person, <span class="string">&#x27;age&#x27;</span>, <span class="number">40</span>)</span><br></pre></td></tr></table></figure><br>getattr() 函数获取某个类实例对象中指定属性的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(clangs,<span class="string">&quot;name&quot;</span>))</span><br></pre></td></tr></table></figure>
<h1 id="import-torch"><a href="#import-torch" class="headerlink" title="import torch"></a>import torch</h1><p><a href="https://mp.weixin.qq.com/s/QdZHMahD3sCtUrOuxkV9jA">PyTorch 常用 Tricks 总结</a></p>
<h2 id="torch-roll"><a href="#torch-roll" class="headerlink" title="torch.roll"></a>torch.roll</h2><p><font color="#999AAA"> torch.roll(input, shifts, dims=None) → Tensor</font></p>
<p><font color="#999AAA"><em>Roll the tensor along the given dimension(s). Elements that are shifted beyond the last position are re-introduced at the first position. If a dimension is not specified, the tensor will be flattened before rolling and then restored to the original shape.</em></font></p>
<p>Parameters</p>
<ul>
<li><strong>input</strong> (<a href="https://pytorch.org/docs/master/tensors.html#torch.Tensor"><em>Tensor</em></a>) – the input tensor.</li>
<li><strong>shifts</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a> <em>or</em> <em>tuple of python:ints</em>) – The number of places by which the elements of the tensor are shifted. If shifts is a tuple, dims must be a tuple of the same size, and each dimension will be rolled by the corresponding value</li>
<li><strong>dims</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a> <em>or</em> <em>tuple of python:ints</em>) – Axis along which to roll</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]).view(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.roll(x, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">tensor([[<span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.roll(x, -<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">tensor([[<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.roll(x, shifts=(<span class="number">2</span>, <span class="number">1</span>), dims=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">tensor([[<span class="number">6</span>, <span class="number">5</span>],</span><br><span class="line">        [<span class="number">8</span>, <span class="number">7</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="torch-nn-Parameter"><a href="#torch-nn-Parameter" class="headerlink" title="torch.nn.Parameter()"></a>torch.nn.Parameter()</h2><p>self.pos_embedding = nn.Parameter(torch.randn(1, num_patches + 1, dim))</p>
<h1 id="将一个不可训练的类型Tensor转换成可以训练的类型parameter，并将parameter绑定到module里（可以优化）"><a href="#将一个不可训练的类型Tensor转换成可以训练的类型parameter，并将parameter绑定到module里（可以优化）" class="headerlink" title="将一个不可训练的类型Tensor转换成可以训练的类型parameter，并将parameter绑定到module里（可以优化）"></a>将一个不可训练的类型Tensor转换成可以训练的类型parameter，并将parameter绑定到module里（可以优化）</h1><p>与torch.tensor([1,2,3],requires_grad=True)的区别，这个只是将参数变成可训练的，并没有绑定在module的parameter列表中。</p>
<h2 id="torch-contiguous"><a href="#torch-contiguous" class="headerlink" title="torch.contiguous()"></a>torch.contiguous()</h2><p>torch.contiguous()方法语义上是“连续的”，经常与torch.permute()、torch.transpose()、torch.view()方法一起使用</p>
<h2 id="touch-view-方法"><a href="#touch-view-方法" class="headerlink" title="touch.view()方法"></a>touch.view()方法</h2><p>对张量改变“形状”其实并没有改变张量在内存中真正的形状，可以理解为：</p>
<ol>
<li>view方法没有拷贝新的张量，没有开辟新内存，与原张量共享内存；</li>
<li>view方法只是重新定义了访问张量的规则，使得取出的张量按照我们希望的形状展现。</li>
</ol>
<p>按照行优先原则，数字在语义和在内存中都是连续的，当我们使用torch.transpose()方法或者torch.permute()方法对张量翻转后，改变了张量的形状</p>
<p>此时如果对t2使用view方法，会报错：</p>
<p>原因是：改变了形状的t2语义上是3行2列的，在内存中还是跟t一样，没有改变，导致如果按照语义的形状进行view拉伸，数字不连续，此时torch.contiguous()方法就派上用场了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">relative_position_bias.permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>).contiguous()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>x.contiguous().view<br>把原先tensor中的数据按照行优先顺序排成一个一维的数据，然后按照参数组合成其他维度的tensor，参数不可为空，-1代表这个位置可以由其他位置的数字来推断</p>
</blockquote>
<h2 id="torch-chunk"><a href="#torch-chunk" class="headerlink" title="torch.chunk()"></a>torch.chunk()</h2><p>chunk方法可以对张量分块，返回一个张量列表：</p>
<p>torch.chunk(tensor, chunks, dim=0) → List of Tensors</p>
<blockquote>
<p>Splits a tensor into a specific number of chunks.</p>
<p>Last chunk will be smaller if the tensor size along the given dimension dim is not divisible by chunks.<br>（如果指定轴的元素个数被chunks除不尽，那么最后一块的元素个数变少）</p>
</blockquote>
<p>Parameters:    </p>
<ul>
<li>tensor (Tensor) – the tensor to split,待分割张量</li>
<li>chunks (int) – number of chunks to return（分割的块数）</li>
<li>dim (int) – dimension along which to split the tensor（沿着哪个轴分块）</li>
</ul>
<h2 id="torch-einsum-爱因斯坦简记法"><a href="#torch-einsum-爱因斯坦简记法" class="headerlink" title="torch.einsum 爱因斯坦简记法"></a>torch.einsum 爱因斯坦简记法</h2><p>对向量、矩阵、张量的求和运算<br>torch.einsum(‘bhid,bhjd-&gt;bhij’,q,k) * self.scale<br>输入q，k，沿下标id</p>
<p>更多讲解请参考：<a href="https://mp.weixin.qq.com/s/FvezivypQBTWkZ6ZYWnBAQ">einsum is all you needed！</a></p>
<h2 id="torch-split-将tensor分成块结构"><a href="#torch-split-将tensor分成块结构" class="headerlink" title="torch.split 将tensor分成块结构"></a>torch.split 将tensor分成块结构</h2><p>torch.split(tensor, split_size_or_sections, dim=0)<br>参数：</p>
<ul>
<li>tesnor：input，待分输入</li>
<li>split_size_or_sections：需要切分的大小(int or list )</li>
<li>dim：切分维度</li>
<li>output：切分后块结构 <class 'tuple'></class></li>
</ul>
<blockquote>
<p>当split_size_or_sections为int时，tenor结构和split_size_or_sections，正好匹配，那么ouput就是大小相同的块结构。如果按照split_size_or_sections结构，tensor不够了，那么就把剩下的那部分做一个块处理。<br>当split_size_or_sections为list时，那么tensor结构会一共切分成len(list)这么多的小块，每个小块中的大小按照list中的大小决定，其中list中的数字总和应等于该维度的大小，否则会报错（注意这里与split_size_or_sections为int时的情况不同）。</p>
</blockquote>
<p>split_size_or_sections为int型时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"> </span><br><span class="line">x = torch.rand(<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>)</span><br><span class="line">y = torch.split(x,<span class="number">2</span>,dim=<span class="number">0</span>) <span class="comment">#按照4这个维度去分，每大块包含2个小块</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y :</span><br><span class="line">    <span class="built_in">print</span>(i.size())</span><br><span class="line"> </span><br><span class="line">output:</span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>])</span><br><span class="line">torch.Size([<span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>])</span><br><span class="line"> </span><br><span class="line">y = torch.split(x,<span class="number">3</span>,dim=<span class="number">0</span>)<span class="comment">#按照4这个维度去分，每大块包含3个小块</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y:</span><br><span class="line">    <span class="built_in">print</span>(i.size())</span><br><span class="line"> </span><br><span class="line">output:</span><br><span class="line">torch.Size([<span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>])</span><br><span class="line">torch.Size([<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>
<p>  split_size_or_sections为list型时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"> </span><br><span class="line">x = torch.rand(<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>)</span><br><span class="line">y = torch.split(x,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],dim=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y:</span><br><span class="line">    <span class="built_in">print</span>(i.size())</span><br><span class="line"> </span><br><span class="line">output:</span><br><span class="line">torch.Size([<span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>])</span><br><span class="line">torch.Size([<span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line">torch.Size([<span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">y = torch.split(x,[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],dim=<span class="number">1</span>) <span class="comment">#2+1+3 等于7,报错</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y:</span><br><span class="line">    <span class="built_in">print</span>(i.size())</span><br><span class="line"> </span><br><span class="line">output:</span><br><span class="line">split_with_sizes expects split_sizes to <span class="built_in">sum</span> exactly to <span class="number">8</span> (<span class="built_in">input</span> tenso<span class="string">r&#x27;s size at dimension 1), but got split_sizes=[2, 1, 3]</span></span><br></pre></td></tr></table></figure>
<h1 id="import-torch-nn"><a href="#import-torch-nn" class="headerlink" title="import torch.nn"></a>import torch.nn</h1><h2 id="nn-Conv2d-groups-in-channels"><a href="#nn-Conv2d-groups-in-channels" class="headerlink" title="nn.Conv2d(groups=in_channels)"></a>nn.Conv2d(groups=in_channels)</h2><p>Depthwise COnv 深度卷积，意思是将输入的每一个通道作为一组，然后分别对其卷积</p>
<h2 id="nn-ModuleList"><a href="#nn-ModuleList" class="headerlink" title="nn.ModuleList"></a>nn.ModuleList</h2><p>它是一个储存不同nn.module，并自动将每个 module 的 parameters 添加到网络之中的容器(extend 和 append方法)。但是，nn.ModuleList 并没有定义一个网络，它只是将不同的模块储存在一起，这些模块之间并没有什么先后顺序可言</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer_branch</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config</span>):</span><br><span class="line">        <span class="built_in">super</span>(Transformer_branch, self).__init__()</span><br><span class="line">        self.encoder_norm = LayerNorm(config.dim, eps=<span class="number">1e-6</span>) <span class="comment">#config.dim=256</span></span><br><span class="line">        self.embedding = Embeddings(config)</span><br><span class="line">        self.layer = nn.ModuleList()</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(config.transformer[<span class="string">&quot;num_layers&quot;</span>]):</span><br><span class="line">            layer = Att_block(config)</span><br><span class="line">            self.layer.append(copy.deepcopy(layer))</span><br><span class="line">        self.decoder = Decoder_vit(config)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = self.embedding(x)</span><br><span class="line">        <span class="keyword">for</span> layer_block <span class="keyword">in</span> self.layer:</span><br><span class="line">            x = layer_block(x)</span><br><span class="line">        encoded = self.encoder_norm(x)</span><br><span class="line">        x_16, x_8, x_4  = self.decoder(encoded)</span><br><span class="line">        <span class="keyword">return</span> x_16, x_8, x_4</span><br></pre></td></tr></table></figure>
<p>注意：nn.Sequential内部实现了forward函数，而nn.ModuleList需要写forward函数</p>
<h2 id="nn-Sequential"><a href="#nn-Sequential" class="headerlink" title="nn.Sequential"></a>nn.Sequential</h2><p>不同于 nn.ModuleList，它已经实现的 forward 函数，而且里面的模块是按照顺序进行排列的，所以我们必须确保前一个模块的输出大小和下一个模块的输入大小是一致的</p>
<h2 id="make-layer"><a href="#make-layer" class="headerlink" title="_make_layer"></a>_make_layer</h2><p>对于一些重复的layer可以采用nn.Sequential先进行封装layer，然后调用<em>make_layer</em>进行实现<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResNet</span>(nn.Module):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,block,layers,num_classes=<span class="number">1000</span></span>):</span><br><span class="line"> </span><br><span class="line">    self.in_channels = <span class="number">64</span></span><br><span class="line">    <span class="built_in">super</span>(ResNet,self).__init__()</span><br><span class="line">    self.conv1 = nn.Conv2d(</span><br><span class="line">        <span class="number">3</span>,<span class="number">64</span>,kernel_size=<span class="number">7</span>,stride=<span class="number">2</span>,padding=<span class="number">3</span>,bias=<span class="literal">False</span></span><br><span class="line">    )</span><br><span class="line">    self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">    self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">    self.maxpool = nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>,padding=<span class="number">1</span>)</span><br><span class="line">    self.layer1 = self._make_layer(block,<span class="number">64</span>,layers[<span class="number">0</span>])</span><br><span class="line">    self.layer2 = self._make_layer(block,<span class="number">128</span>,layers[<span class="number">1</span>],stride=<span class="number">2</span>)</span><br><span class="line">    self.layer3 = self._make_layer(block,<span class="number">256</span>,layers[<span class="number">2</span>],stride=<span class="number">2</span>)</span><br><span class="line">    self.layer4 = self._make_layer(block,<span class="number">512</span>,layers[<span class="number">3</span>],stride=<span class="number">2</span>)</span><br><span class="line">    self.avgpool = nn.AvgPool2d(<span class="number">7</span>,stride=<span class="number">1</span>)</span><br><span class="line">    self.fc = nn.Linear(<span class="number">512</span>*block.expansion,num_classes)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_make_layer</span>(<span class="params">self,block,out_channels,blocks,stride=<span class="number">1</span></span>):</span><br><span class="line">    downsample = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> stride!=<span class="number">1</span> <span class="keyword">or</span> self.in_channels != out_channels*block.expansion:</span><br><span class="line"> </span><br><span class="line">        downsample = nn.Sequential(</span><br><span class="line">            nn.Conv2d(</span><br><span class="line">                self.in_channels,out_channels*block.expansion,kernel_size=<span class="number">1</span>,</span><br><span class="line">                stride=stride,bias=<span class="literal">False</span> </span><br><span class="line">            ),</span><br><span class="line">            nn.BatchNorm2d(out_channels*block.expansion)</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    layers = []</span><br><span class="line">    <span class="comment">## 虚线部分</span></span><br><span class="line">    layers.append(block(self.in_channels,out_channels,stride,downsample))</span><br><span class="line">    <span class="comment">## 更新 in_channels</span></span><br><span class="line">    self.in_channels = out_channels*block.expansion </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,blocks):</span><br><span class="line">        layers.append(block(self.in_channels,out_channels))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(*layers)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line"> </span><br><span class="line">    x = self.conv1(x)</span><br><span class="line">    x = self.bn1(x)</span><br><span class="line">    x = self.relu(x)</span><br><span class="line">    x = self.maxpool(x)</span><br><span class="line"> </span><br><span class="line">    x2 = self.layer1(x)</span><br><span class="line">    x3 = self.layer2(x2)</span><br><span class="line">    x4 = self.layer3(x3)</span><br><span class="line"> </span><br><span class="line">    x5 = self.layer4(x4)</span><br><span class="line">    x6 = self.avgpool(x5)</span><br><span class="line">    x7 = x6.view(x6.size(<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> self.fc(x7)</span><br></pre></td></tr></table></figure></p>
<h2 id="nn-Linear"><a href="#nn-Linear" class="headerlink" title="nn.Linear"></a>nn.Linear</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nn1 = torch.nn.Linear(<span class="number">100</span>, <span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>input1 = torch.randn(<span class="number">140</span>, <span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>output1 = nn1(input1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>output1.size()</span><br><span class="line">torch.Size([<span class="number">140</span>, <span class="number">50</span>])</span><br></pre></td></tr></table></figure>
<p>张量的大小由 140 x 100 变成了 140 x 50</p>
<p>执行的操作是：</p>
<p><font color="#999AAA"> <em>[140,100]×[100,50]=[140,50]</em></font></p>
<h2 id="nn-Unfold"><a href="#nn-Unfold" class="headerlink" title="nn.Unfold"></a>nn.Unfold</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.Unfold(kernel_size,dilation=<span class="number">1</span>,padding=<span class="number">0</span>,stride=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>从一个batch的样本中，提取出滑动的局部区域块（类似卷积操作提取kernel filter对应的滑动窗口）<br>(N,C,H,W)  N=batch_size,C=channel个数<br>输出 （N,C*kernel_size长和宽乘积,L）  L是滑动剪裁后得到的区块的数量</p>
<p><strong>torch.nn.Fold</strong>   将提取出的滑动局部区域还原成batch张量</p>
<h2 id="共享权重shared-weight"><a href="#共享权重shared-weight" class="headerlink" title="共享权重shared weight"></a>共享权重shared weight</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">branches_1 =  self.conv3*<span class="number">3</span>(x)</span><br><span class="line"></span><br><span class="line">branches_2 = F.conv2d(x,self.conv3*<span class="number">3.</span>weight,padding=<span class="number">2</span>,dilation=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="归一化层"><a href="#归一化层" class="headerlink" title="归一化层"></a>归一化层</h2><p>BN，LN，IN，GN从学术化上解释差异：</p>
<ul>
<li>BatchNorm：batch方向做归一化，算NHW的均值，对小batchsize效果不好；BN主要缺点是对batchsize的大小比较敏感，由于每次计算均值和方差是在一个batch上，所以如果batchsize太小，则计算的均值、方差不足以代表整个数据分布</li>
</ul>
<ul>
<li>LayerNorm：channel方向做归一化，算CHW的均值，主要对RNN作用明显；<br>InstanceNorm：一个channel内做归一化，算H*W的均值，用在风格化迁移；因为在图像风格化中，生成结果主要依赖于某个图像实例，所以对整个batch归一化不适合图像风格化中，因而对HW做归一化。可以加速模型收敛，并且保持每个图像实例之间的独立。</li>
<li>GroupNorm：将channel方向分group，然后每个group内做归一化，算(C//G)HW的均值；这样与batchsize无关，不受其约束。<br>SwitchableNorm是将BN、LN、IN结合，赋予权重，让网络自己去学习归一化层应该使用什么方法。</li>
</ul>
<h2 id="permute-维度换位"><a href="#permute-维度换位" class="headerlink" title="permute 维度换位"></a>permute 维度换位</h2><p>(28,28,3) img.permute(2,0,1)   (3,28,28) </p>
<h2 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t(<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">&gt; t.flatten(start_dim=<span class="number">1</span>).shape</span><br><span class="line">torch.Size([<span class="number">3</span>, <span class="number">16</span>])</span><br></pre></td></tr></table></figure>
<h2 id="Drop-path"><a href="#Drop-path" class="headerlink" title="Drop_path"></a>Drop_path</h2><p>将深度学习模型中的多分支结构随机删除</p>
<h1 id="import-其他包"><a href="#import-其他包" class="headerlink" title="import 其他包"></a>import 其他包</h1><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>我们寻常意义的复制就是深复制，即将被复制对象完全再复制一遍作为独立的新个体单独存在。所以改变原有被复制对象不会对已经复制出来的新对象产生影响。<br>—–而浅复制并不会产生一个独立的对象单独存在，他只是将原有的数据块打上一个新标签，所以当其中一个标签被改变的时候，数据块就会发生变化，另一个标签也会随之改变。这就和我们寻常意义上的复制有所不同了。</p>
<p>对于简单的 object，用 shallow copy 和 deep copy 没区别</p>
<p>复杂的 object， 如 list 中套着 list 的情况，shallow copy 中的 子list，并未从原 object 真的「独立」出来。也就是说，如果你改变原 object 的子 list 中的一个元素，你的 copy 就会跟着一起变。这跟我们直觉上对「复制」的理解不同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>origin = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="comment">#origin 里边有三个元素：1， 2，[3, 4]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cop1 = copy.copy(origin)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cop2 = copy.deepcopy(origin)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cop1 == cop2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cop1 <span class="keyword">is</span> cop2</span><br><span class="line"><span class="literal">False</span> </span><br><span class="line"><span class="comment">#cop1 和 cop2 看上去相同，但已不再是同一个object</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>origin[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&quot;hey!&quot;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>origin</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="string">&#x27;hey!&#x27;</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cop1</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="string">&#x27;hey!&#x27;</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cop2</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<p>把origin内的子list [3, 4] 改掉了一个元素，观察 cop1 和 cop2<br>更详细地请参考 <a href="https://blog.csdn.net/u010712012/article/details/79754132">https://blog.csdn.net/u010712012/article/details/79754132</a></p>
<h2 id="ml-connections"><a href="#ml-connections" class="headerlink" title="ml_connections"></a>ml_connections</h2><p>ML Collections是为ML use cases而设计的一个Python Collections的一个库。它的两个类是ConfigDict和FrozenConfigDict，是”dict-like” 的数据结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ml_collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_config</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns the ViT configuration.&quot;&quot;&quot;</span></span><br><span class="line">    config = ml_collections.ConfigDict()</span><br><span class="line">    config.transformer = ml_collections.ConfigDict()</span><br><span class="line">    config.transformer.mlp_dim = <span class="number">786</span></span><br><span class="line"><span class="built_in">print</span>(config.integer_field) <span class="comment"># 输出结果 123.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&#x27;integer_field&#x27;</span>]) <span class="comment"># 也输出123.</span></span><br></pre></td></tr></table></figure>
<h2 id="einops-处理张量维度"><a href="#einops-处理张量维度" class="headerlink" title="einops 处理张量维度"></a>einops 处理张量维度</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> einops <span class="keyword">import</span> rearrange, reduce, repeat</span><br><span class="line"></span><br><span class="line"><span class="comment"># rearrange elements according to the pattern</span></span><br><span class="line">output_tensor = rearrange(input_tensor, <span class="string">&#x27;t b c -&gt; b c t&#x27;</span>)</span><br><span class="line"><span class="comment"># combine rearrangement and reduction</span></span><br><span class="line">output_tensor = reduce(input_tensor, <span class="string">&#x27;b c (h h2) (w w2) -&gt; b h w c&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, h2=<span class="number">2</span>, w2=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># copy along a new axis </span></span><br><span class="line">output_tensor = repeat(input_tensor, <span class="string">&#x27;h w -&gt; h w c&#x27;</span>, c=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原文链接：https://blog.csdn.net/ViatorSun/article/details/116010049</span></span><br></pre></td></tr></table></figure>
<h3 id="rearrange-维度调整"><a href="#rearrange-维度调整" class="headerlink" title="rearrange 维度调整"></a>rearrange 维度调整</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rearrange(ims[<span class="number">0</span>], <span class="string">&#x27;h w c -&gt; w h c&#x27;</span>)		<span class="comment"># 调换维度</span></span><br><span class="line"></span><br><span class="line">rearrange(ims, <span class="string">&#x27;b h w c -&gt; (b h) w c&#x27;</span>)  <span class="comment"># 合并维度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or compose a new dimension of batch and width</span></span><br><span class="line">rearrange(ims, <span class="string">&#x27;b h w c -&gt; h (b w) c&#x27;</span>)</span><br><span class="line">rearrange(ims, <span class="string">&#x27;b h w c -&gt; h (b w) c&#x27;</span>).shape</span><br><span class="line"></span><br><span class="line">[<span class="number">6</span>, <span class="number">96</span>, <span class="number">96</span>, <span class="number">3</span>] -&gt; [<span class="number">96</span>, (<span class="number">6</span> * <span class="number">96</span>), <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.mean(-<span class="number">1</span>)</span><br><span class="line">reduce(x, <span class="string">&#x27;b h w c -&gt; b h w&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"><span class="comment"># average over batch</span></span><br><span class="line">reduce(ims, <span class="string">&#x27;b h w c -&gt; h w c&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"><span class="comment"># this is mean-pooling with 2x2 kernel</span></span><br><span class="line"><span class="comment"># image is split into 2x2 patches, each patch is averaged</span></span><br><span class="line"><span class="comment"># 变小了</span></span><br><span class="line">reduce(ims, <span class="string">&#x27;b (h h2) (w w2) c -&gt; h (b w) c&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, h2=<span class="number">2</span>, w2=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># yet another example. Can you compute result shape?</span></span><br><span class="line">reduce(ims, <span class="string">&#x27;(b1 b2) h w c -&gt; (b2 h) (b1 w)&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, b1=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="torch-Tensor-4种常见乘法"><a href="#torch-Tensor-4种常见乘法" class="headerlink" title="torch.Tensor 4种常见乘法"></a>torch.Tensor 4种常见乘法</h2><h3 id="点乘：即-，element-wise乘法"><a href="#点乘：即-，element-wise乘法" class="headerlink" title="点乘：即*，element-wise乘法"></a>点乘：即*，element-wise乘法</h3><ul>
<li>原则是如果a与b的size不同，则以某种方式将a或b进行复制，使得复制后的a和b的size相同，然后再将a和b做element-wise的乘法      标量</li>
<li><p>Tensor与标量k做*乘法的结果是Tensor的每个元素乘以k（相当于把k复制成与lhs大小相同，元素全为k的Tensor）.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.ones(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">    [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">    [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a * <span class="number">2</span></span><br><span class="line">tensor([[<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">    [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">    [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>]])</span><br></pre></td></tr></table></figure>
</li>
<li><p>一维向量<br>Tensor与行向量做*乘法的结果是每列乘以行向量对应列的值（相当于把行向量的行复制，成为与lhs维度相同的Tensor）. 注意此时要求Tensor的列数与行向量的列数相等。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.ones(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">    [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">    [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = torch.Tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a * b</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>],</span><br><span class="line">    [<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>],</span><br><span class="line">    [<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.ones(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">    [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">    [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = torch.Tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a * b</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>],</span><br><span class="line">    [<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>],</span><br><span class="line">    [<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>]])</span><br></pre></td></tr></table></figure>
<ul>
<li>矩阵<br>经Arsmart在评论区提醒，增补一个矩阵 <em> 矩阵的例子，感谢Arsmart的热心评论！<br>如果两个二维矩阵A与B做点积A </em> B，则要求A与B的维度完全相同，即A的行数=B的行数，A的列数=B的列数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a * a</span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>
<h5 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast"></a>broadcast</h5><p>点积是broadcast的。broadcast是torch的一个概念，简单理解就是在一定的规则下允许高维Tensor和低维Tensor之间的运算。broadcast的概念稍显复杂，在此不做展开，可以参考官方文档关于broadcast的介绍. 在torch.matmul里会有关于broadcast的应用的一个简单的例子。<br>这里举一个点积broadcast的例子。在例子中，a是二维Tensor，b是三维Tensor，但是a的维度与b的后两位相同，那么a和b仍然可以做点积，点积结果是一个和b维度一样的三维Tensor，运算规则是：若c = a <em> b, 则c[i,</em>,<em>] = a </em> b[i, <em>, </em>]，即沿着b的第0维做二维Tensor点积，或者可以理解为运算前将a沿着b的第0维也进行了expand操作，即a = a.expand(b.size()); a * b。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = torch.tensor([[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>]],[[-<span class="number">1</span>,-<span class="number">2</span>],[-<span class="number">2</span>,-<span class="number">3</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a * b</span><br><span class="line">tensor([[[ <span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">     [ <span class="number">4</span>, <span class="number">9</span>]],</span><br><span class="line"></span><br><span class="line">    [[-<span class="number">1</span>, -<span class="number">4</span>],</span><br><span class="line">     [-<span class="number">4</span>, -<span class="number">9</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b * a</span><br><span class="line">tensor([[[ <span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">     [ <span class="number">4</span>, <span class="number">9</span>]],</span><br><span class="line"></span><br><span class="line">    [[-<span class="number">1</span>, -<span class="number">4</span>],</span><br><span class="line">     [-<span class="number">4</span>, -<span class="number">9</span>]]])</span><br></pre></td></tr></table></figure>
<p>其实，上面提到的二维Tensor点积标量、二维Tensor点积行向量，都是发生在高维向量和低维向量之间的，也可以看作是broadcast.</p>
<h3 id="torch-mul"><a href="#torch-mul" class="headerlink" title="torch.mul"></a>torch.mul</h3><p>官方文档关于torch.mul的介绍. 用法与*乘法相同，也是element-wise的乘法，也是支持broadcast的。</p>
<h3 id="torch-mm"><a href="#torch-mm" class="headerlink" title="torch.mm"></a>torch.mm</h3><p>官方文档关于torch.mm的介绍. 数学里的矩阵乘法，要求两个Tensor的维度满足矩阵乘法的要求.</p>
<h3 id="torch-matmul"><a href="#torch-matmul" class="headerlink" title="torch.matmul"></a>torch.matmul</h3><p>官方文档关于torch.matmul的介绍. torch.mm的broadcast版本.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.ones(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = torch.ones(<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.matmul(a, b)</span><br><span class="line">tensor([[[<span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">     [<span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">     [<span class="number">4.</span>, <span class="number">4.</span>]],</span><br><span class="line"></span><br><span class="line">    [[<span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">     [<span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">     [<span class="number">4.</span>, <span class="number">4.</span>]],</span><br><span class="line">     </span><br><span class="line">    [[<span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">     [<span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">     [<span class="number">4.</span>, <span class="number">4.</span>]],</span><br><span class="line">     </span><br><span class="line">    [[<span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">     [<span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">     [<span class="number">4.</span>, <span class="number">4.</span>]],</span><br><span class="line">     </span><br><span class="line">    [[<span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">     [<span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">     [<span class="number">4.</span>, <span class="number">4.</span>]]])</span><br></pre></td></tr></table></figure>
<h3 id="torch-broadcast-tensors"><a href="#torch-broadcast-tensors" class="headerlink" title="torch.broadcast_tensors()"></a>torch.broadcast_tensors()</h3><p>Broadcasting 是指，在运算中，不同大小的两个 array 应该怎样处理的操作。通常情况下，小一点的数组会被 broadcast 到大一点的，这样才能保持大小一致。Broadcasting 过程中的循环操作都在 C 底层进行，所以速度比较快。但也有一些情况下 Broadcasting 会带来性能上的下降。</p>
<p>两个 Tensors 只有在下列情况下才能进行 broadcasting 操作：</p>
<ul>
<li>每个 tensor 至少有一维</li>
<li>遍历所有的维度，从尾部维度开始，每个对应的维度大小<strong>要么相同，要么其中一个是 1，要么其中一个不存在</strong>。</li>
</ul>
<p>一个将tensor扩充的函数，可以传两个参数，并且最后得到的结果会变成第二个参数的形状，值是填充的第一个参数的值。</p>
<p>函数一共有两个返回结果，第二个结果的形状和第一个结果相同，但是填充的值都是0</p>
]]></content>
      <categories>
        <category>研究生期间</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>多模态简单调研</title>
    <url>/2021/08/17/010-%E5%A4%9A%E6%A8%A1%E6%80%81%E7%AE%80%E5%8D%95%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="多模态融合"><a href="#多模态融合" class="headerlink" title="多模态融合"></a>多模态融合</h2><p>四个方面的多模态数据融合算法研究：<br>不完整模态分析融合<br>增量模态聚类融合<br>异构模态迁移融合<br>低维模态共享融合</p>
<p><img src="https://img-blog.csdnimg.cn/4afb8f5ddc804bd7bf60ab614d2a3d12.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1.<br>早期融合，又称为特征融合，是指对模态进行特征提取之后立刻进行的一种融合方式。特征融合的优势在于可以在早期利用来自不同模态的多个特征之间的相关性，适用于模态之间高度相关的情况。例如，在结合语音识别的音频和视频特征时采用早期融合[6]。但对于特征的提取难度较大[7]，并不是最理想的融合方法。<br>2.<br>后期融合，也称为决策层融合，指的是在每种模态都做出决策（分类或回归）之后才进行的融合。进行后期融合，需要使用相应的模型对不相同的模态进行训练，再对这些模型输出的结果进行融合。与之前的早期融合作比较，该融合方式可以处理简单的数据异步性。另一个优势是允许使用最适合分析每种单一模态的方法，如音频使用<strong>隐马尔可夫模型</strong>(Hidden Markov Model，HMM)、图像使用可支持向量机(Support Vector Machines，SVM)。</p>
<p>根据具体融合操作不同，可以大致的划分为三种主要的方法：基于拼接和线性组合等简单融合操作的方法、基于注意力机制的融合方法和基于双线性池化的融合方法。这三种方法均是通过对特征向量进行相关操作达到多模态信息的融合及表达。</p>
<p>多模态网络架构主要分为三种，即协同架构、联合架构和编解码器架构。<br>1.协同架构<br><img src="https://img-blog.csdnimg.cn/3ef8a2ef7a684154a27d507a44aeb4e6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.联合架构<br><img src="https://img-blog.csdnimg.cn/318e0da4d8b04ffaacf329c5bc2d9b27.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.编解码器架构<br><img src="https://img-blog.csdnimg.cn/b941b0f85a76463f90bb43d8a0603689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>多模态融合方法分为模型无关的融合方法和模型相关方法两种。模型无关方法有早期、晚期、混合融合三种；模型相关方法包括多核学习方法、图像模型方法和神经网络方法三种。单一模态的表示、融合完成后信息的表示是融合过程的基础，确保特征提取及融合过程中信息的完整性是融合成功的关键。</p>
<p><img src="https://img-blog.csdnimg.cn/c5897396c790488c87b1da4f63513050.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6cfe46475a654ecba08b2595b3e9ca71.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/fbc00ef07f2e401d9da528eea7fbd5f3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现有的多模态数据融合分析方法：<br><strong>1、基于阶段的融合算法</strong>：<br>　　在数据挖掘任务的不同阶段使用不同的模态数据完成相应的融合分析。（可做先验算法）</p>
<p>　　特点：不需要模态数据间的一致性（即不同模态数据间处于松耦合）</p>
<p>　　eg：1、区域图划分与区域图构建（模态：路网和出租车轨迹）。2、好友推荐系统（模态：空间轨迹数据和空间点静态分类数据）<br><strong>2、基于特征的融合方法</strong><br>早的基于特征的融合方法，直接将所有模态特征进行串联融合，然后基于串联后<br>的特征完成聚类、分类等数据挖掘任务。由于不同模态的表示、分布和密度均可能不同，<br>简单的属性连接会忽略模态特有的统计属性和模态间的相关关系，并产生数据的冗余与<br>依赖［１９］。一些改进算法在目标函数中添加稀疏规则化因子控制融合特征的冗余，在模型<br>的训练中将冗余特征的权重近似分配为零［２（）］。<br>最近的研究中，更多方法利用深度神经网络学习不同模态数据的统一特征表示。深<br>度神经网络能够学习得到数据的多层表示与抽象，进而将数据转换成深度网络的高层抽<br>象特征，这种新的特征比传统手工特征更具表达能力</p>
<p><strong>3、基于语义的融合算法：</strong><br>        基于特征的融合方法只是将每个特征当做实数或分类值，而不关注每个特征的具体意义。与基于特征的融合方法不同，基于语义的方法理解每个模态的数据含义及不同模<br>态特征之间的关系，在数据融合过程中利用人类思考问题的方式抽象不同模态的语义含<br>义完成跨模态数据融合。现有的基于语义的融合算法大致分为<strong>共训练、多核学习、子空间学习、概率依赖和迁移学习五类</strong>。<br>        理解每个模态的数据含义及不同模态特征之间的关系，在数据融合过程中利用人类思考问题的方式抽象不同模态的语义含义完成跨模态数据融合。<br>　　现有的基于语义的融合算法大致分为：<br><strong>3.1、共训练方法：</strong><br>　　通过轮流训练使得两个模态数据的协同度最大。<br>　　　　三个需求（假设）：1、每个模态有充分的数据；2、基于共生特征两个模态的目标函数都能以较高概率预测到相同的数据类标签；3、给定类标签，模态间条件独立。</p>
<p><strong>3.2、多核学习方法：</strong><br>　　　　利用预定义的一组核函数学习一个基于核函数的优化的线性或非线性组合。<br>　　　　<img src="https://img-blog.csdnimg.cn/d454a01ea0fe4646b53e5e763b00650e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>多核学习算法是机器学习的一类算法，他们利用预定义的一组核函数学习一个基于核函数的优化的线性或非线性组合，完成具体数据任务分析。一个核是一个基于数据的假设，可能是一个相似性概念、一个分类器或者一个回归量。根据文献，多核学习有两种方式<br>１）不同核对应不同的相似性概念，学习函数挑选最好的核计算结果或整合所有核的计算结果，这种多核学习方法利用所有模态数据完成每个核的训练，不适用于多模态融合学习；<br>２）利用不同模态数据训练不同的核，因此整合所有核学习结果相当于对所有模态信息进行融合，现有的多核结果整合算法可分为三类：线性、非线性和数据依赖整合，文献［３］已经对现有的多核学习方法进行详细的分析总结。<br>多核学习用于多模态分析主要是因为多核学习中不同核自然的对应于不同的模态，对各核进行适当的整合能够提升学习结果的性能。例如，等人将多核学习应用到多模态情感识别和语义分析中［３６］，通过对语义、视频和文本三个模态特征使用不同的核得到比单核模态融合更好的分析结果。文献［３７］将多核学习应用到人脸识别，提出基于多核稀疏表示的分类学习算法，算法在多核空间内同时执行稀疏编码和字典学习，通过可能核合并和稀疏系数计算得到核的优化权重。</p>
<p><strong>3.3、子空间学习方法：</strong><br>　　　　假设所以模态均可以投影到同一语义共享子空间，在子空间内可以完成聚类、分类等数据挖掘任务。（共享子空间的特征维度小于任何一个模态数据维度（维度灾难））<br>　　　　<img src="https://img-blog.csdnimg.cn/56b93f95d230472ab24c24ecd023344a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>[1]张磊,赵耀,朱振峰.跨媒体语义共享子空间学习研究进展[J].计算机学报,2017,40(06):1394-1421.<br><img src="https://img-blog.csdnimg.cn/ac7b0ef8044d4ef6a972aeecb3ff1f21.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/f5ec4394bca84c72a6fba20a9ef7aea9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1c01f90c360f4bf8baf4c466a508509c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/51cfc4eee10544029df2f7e21bebe3c2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/bbd53d0421484c7488ea8eaf3a429d19.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c5a386d68dd7405dab1985de802aec49.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/567969a1e97d48a8b76db3f3a06aaf15.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f949c43201d845e99d6cc4aa49ce3520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/7a5497b0de4144949601d476357566f8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f249f73f97834b0d848a1c3ce97ce71c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2939787aab794675b2dc07442e493712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>研究生期间</category>
      </categories>
      <tags>
        <tag>调研</tag>
        <tag>多模态</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM模板大全</title>
    <url>/2019/04/09/012-ACM%E6%A8%A1%E6%9D%BF%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h3 id="线段树单点修改区间求和模板"><a href="#线段树单点修改区间求和模板" class="headerlink" title="线段树单点修改区间求和模板"></a>线段树单点修改区间求和模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson l,mid,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson mid+1,r,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="type">int</span> sum[maxn&lt;&lt;<span class="number">2</span>],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[rt] = sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span><span class="comment">//建树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;sum[rt]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lson);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">push_up</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> val,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span><span class="comment">//更新</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[rt]+=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid =l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=mid) <span class="built_in">upd</span>(p,val,lson);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">upd</span>(p,val,rson);</span><br><span class="line">    <span class="built_in">push_up</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span><span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;R&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sum[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid =l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) ret+=<span class="built_in">query</span>(L,R,lson);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) ret+=<span class="built_in">query</span>(L,R,rson);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Kruskal算法并查集求最小生成树"><a href="#Kruskal算法并查集求最小生成树" class="headerlink" title="Kruskal算法并查集求最小生成树"></a>Kruskal算法并查集求最小生成树</h3><p>```cpp</p>
<h1 id="define-maxn-25005"><a href="#define-maxn-25005" class="headerlink" title="define maxn 25005"></a>define maxn 25005</h1><p>using namespace std;<br>/<em>边的定义</em>/<br>typedef struct edge<br>{<br>       int x,y;     //边的两个端点编号<br>       int cost;    //边权<br>}edge;<br>edge s[maxn];<br>int t,n,f[510];<br>/<em>边的比较函数</em>/<br>bool cmp(edge a,edge b)<br>{<br>       return a.cost<b.cost; } void init() { for(int i="1;i<=n;i++)" f[i]="i;" int find(int x) *并查集查询函数，返回x所在集合的根结点* return f[x]="=x?x:f[x]=find(f[x]);" merge(int x,int y) fx="find(x);" fy="find(y);" f[fx]="fy;" *kruskal算法求无向图的最小生成树* kruskal() sort(s+1,s+1+t,cmp); ans="0,k=0;" if(find(s[i].x)!="find(s[i].y))" merge(s[i].x,s[i].y); k++; if(k="=n-1)" ans; main() z; scanf("%d",&z); while(z--) scanf("%d",&n); x; init();t="1;" j="1;j<=n;j++)" scanf("%d",&x); if(j>i&amp;&amp;x!=0)<br>                   {<br>                       s[t].x=i;s[t].y=j;<br>                       s[t].cost=x;<br>                       t++;<br>                   }<br>               }<br>           }<br>           int res=Kruskal();<br>           printf(“%d\n”,res);<br>       }<br>}</b.cost;></p>
<p>``</p>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>ACM</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Vision Transformer</title>
    <url>/2021/07/10/011-Vision-Transformer/</url>
    <content><![CDATA[<p>一般使用的patch_size大小是16*16，可以通过减小patch_size来完成更精细化的tokenization，但是序列的长度N=HW/P^2过长，假设p从16变为4，序列的长度会变为原来的16倍，而ViT模型的计算量与序列长度的平方成正比，计算量就会相应地变成原来的256倍</p>
<blockquote>
<p>1、想办法将位置信息融入到输入中，这构成了绝对位置编码的一般做法；2、想办法微调一下Attention结构，使得它有能力分辨不同位置的Token，这构成了相对位置编码的一般做法。<br>相对位置并没有完整建模每个输入的位置信息，而是在算Attention的时候考虑当前位置与被Attention的位置的相对距离，由于自然语言一般更依赖于相对位置，所以相对位置编码通常也有着优秀的表现。对于相对位置编码来说，它的灵活性更大，更加体现出了研究人员的“天马行空”。</p>
</blockquote>
<h2 id="2021-CoaT：Co-Scale-Conv-Attentional-ImageTransformers【开源】【分类】"><a href="#2021-CoaT：Co-Scale-Conv-Attentional-ImageTransformers【开源】【分类】" class="headerlink" title="2021-CoaT：Co-Scale Conv-Attentional ImageTransformers【开源】【分类】"></a>2021-CoaT：Co-Scale Conv-Attentional ImageTransformers【开源】【分类】</h2><p>【代码】： <a href="https://github.com/mlpc-ucsd/CoaT">https://github.com/mlpc-ucsd/CoaT</a></p>
<p>CoaT为图像Transformer提供了丰富的多尺度和上下文建模能力</p>
<p><strong>摘要</strong><br>在本文中，我们介绍了Co-scale conv-attentional image Transformers（CoaT），这是一种基于Transformer的图像分类器，配备了co-scale和conv-attentional机制。首先，co-scale机制在各个尺度上都保持了Transformers编码器分支的完整性，同时允许在不同尺度下学习的表示形式能够有效地彼此通信。我们设计了一系列的串行和并行块，以实现co-scale 注意力机制。其次，我们通过一种高效的类似于卷积的实现方式，在因式注意模块中实现相对位置嵌入公式，设计了一种factorized attention机制。 CoaT为图像Trasformer提供了丰富的多尺度和上下文建模功能。在ImageNet上，与类似大小的卷积神经网络和图像/视觉Transformer相比，相对较小的CoaT模型可获得更好的分类结果。 CoaT骨干网的有效性在目标检测和实例分割上也得到了说明，证明了其对下游计算机视觉任务的适用性。</p>
<ol>
<li><img src="https://img-blog.csdnimg.cn/img_convert/e5c90f76658dacbdda4514770a973802.png" alt="在这里插入图片描述"><br>左边是CoaT-Lite，只有串行模块<br>右边是CoaT，加上并行模块</li>
</ol>
<h2 id="2021-CPVT：Conditional-Positional-Encodings-for-Vision-Transformer【开源】【分类】【美团】"><a href="#2021-CPVT：Conditional-Positional-Encodings-for-Vision-Transformer【开源】【分类】【美团】" class="headerlink" title="2021-CPVT：Conditional Positional Encodings for Vision Transformer【开源】【分类】【美团】"></a>2021-CPVT：Conditional Positional Encodings for Vision Transformer【开源】【分类】【美团】</h2><p>又名： Do We Really Need Explicit Position Encodings for Vision Transformers<br>【代码】： <a href="https://github.com/Meituan-AutoML/CPVT">https://github.com/Meituan-AutoML/CPVT</a>   【代码是和Twins一起放出来的，这个链接没有代码】<br>成功的视觉任务位置编码应满足以下要求：</p>
<ol>
<li>是输入序列排列可变但平移不变</li>
<li>具有归纳性并且能够处理比训练期间更长的序列</li>
<li>具有一定程度能提供绝对位置的能力</li>
</ol>
<blockquote>
<p>CPVT的PEG（Positional Encoding Generator）通过卷积聚合邻域内的特征生成位置编码，且边缘的零填充对于模型知道绝对位置很重要，并且做了消融实验来验证，分析原因是因为：绝对位置信息在物体分类中起着重要作用，每个图象的类别主要由中心的对象标记，模型需要绝对位置来确定哪个补丁位于中心。</p>
</blockquote>
<p>全局平均池化GAP替换class token</p>
<h2 id="2021-CrossViT-Cross-Attention-Multi-Scale-Vision-Transformer-for-Image-Classification【民间代码】"><a href="#2021-CrossViT-Cross-Attention-Multi-Scale-Vision-Transformer-for-Image-Classification【民间代码】" class="headerlink" title="2021-CrossViT: Cross-Attention Multi-Scale Vision Transformer for Image Classification【民间代码】"></a>2021-CrossViT: Cross-Attention Multi-Scale Vision Transformer for Image Classification【民间代码】</h2><p>【代码】： <a href="https://github.com/rishikksh20/CrossViT-pytorch">https://github.com/rishikksh20/CrossViT-pytorch</a><br>yangzhi</p>
<h2 id="2021-CAT-Cross-Attention-in-Vision-Transformer【开源】【分类】"><a href="#2021-CAT-Cross-Attention-in-Vision-Transformer【开源】【分类】" class="headerlink" title="2021-CAT: Cross Attention in Vision Transformer【开源】【分类】"></a>2021-CAT: Cross Attention in Vision Transformer【开源】【分类】</h2><p>【代码】： </p>
<h2 id="2021-MSG-Transformer：Exchanging-Local-Spatial-Information-by-Manipulating-Messenger-Tokens【开源】【分类】【结果不好】"><a href="#2021-MSG-Transformer：Exchanging-Local-Spatial-Information-by-Manipulating-Messenger-Tokens【开源】【分类】【结果不好】" class="headerlink" title="2021-MSG-Transformer：Exchanging Local Spatial Information by Manipulating Messenger Tokens【开源】【分类】【结果不好】"></a>2021-MSG-Transformer：Exchanging Local Spatial Information by Manipulating Messenger Tokens【开源】【分类】【结果不好】</h2><p>【代码】： <a href="https://github.com/hustvl/MSG-Transformer">https://github.com/hustvl/MSG-Transformer</a></p>
<p><strong>摘要：</strong><br>Transformers 提供了一种设计用于视觉识别的神经网络的新方法。 与卷积网络相比，Transformers 享有<strong>在每个阶段引用全局特征的能力</strong>，但注意力模块带来更高的计算开销，阻碍了 Transformer 处理高分辨率视觉数据的应用。 本文旨在缓解效率和灵活性之间的冲突，为此我们为每个区域提出了一个专门的token作为信使（MSG）。 因此，通过<strong>操纵这些 MSG tokens，人们可以跨区域灵活地交换视觉信息</strong>，并降低计算复杂度。 然后，我们将 MSG token集成到名为 MSG-Transformer 的多尺度架构中。 在标准图像分类和目标检测中，MSG-Transformer 实现了具有竞争力的性能，并且加速了 GPU 和 CPU 上的推理。</p>
<h2 id="2021-Swin-Transformer【已开源】【分类】"><a href="#2021-Swin-Transformer【已开源】【分类】" class="headerlink" title="2021-Swin Transformer【已开源】【分类】"></a>2021-Swin Transformer【已开源】【分类】</h2><p>【代码】：<br><a href="https://github.com/microsoft/Swin-Transformer">https://github.com/microsoft/Swin-Transformer</a><br><a href="https://github.com/berniwal/swin-transformer-pytorch">https://github.com/berniwal/swin-transformer-pytorch</a></p>
<h2 id="2021-Swin-Unet【已开源】【分割】【2021CVPR】"><a href="#2021-Swin-Unet【已开源】【分割】【2021CVPR】" class="headerlink" title="2021-Swin-Unet【已开源】【分割】【2021CVPR】"></a>2021-Swin-Unet【已开源】【分割】【2021CVPR】</h2><p>【代码】： <a href="https://github.com/HuCaoFighting/Swin-Unet">https://github.com/HuCaoFighting/Swin-Unet</a></p>
<p><img src="https://img-blog.csdnimg.cn/20210715201235141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2021-UCTransNet-Rethinking-the-Skip-Connections-in-U-Net-from-a-Channel-wise-Perspective-with-Transformer【已开源】【分割】"><a href="#2021-UCTransNet-Rethinking-the-Skip-Connections-in-U-Net-from-a-Channel-wise-Perspective-with-Transformer【已开源】【分割】" class="headerlink" title="2021-UCTransNet: Rethinking the Skip Connections in U-Net from a Channel-wise Perspective with Transformer【已开源】【分割】"></a>2021-UCTransNet: Rethinking the Skip Connections in U-Net from a Channel-wise Perspective with Transformer【已开源】【分割】</h2><p>【代码】：<a href="https://github.com/McGregorWwww/UCTransNet">https://github.com/McGregorWwww/UCTransNet</a></p>
<h2 id="2021-CoTNet-Contextual-Transformer-Networks-for-Visual-Recognition【已开源】【分类】"><a href="#2021-CoTNet-Contextual-Transformer-Networks-for-Visual-Recognition【已开源】【分类】" class="headerlink" title="2021- CoTNet-Contextual Transformer Networks for Visual Recognition【已开源】【分类】"></a>2021- CoTNet-Contextual Transformer Networks for Visual Recognition【已开源】【分类】</h2><p>【代码】：<a href="https://github.com/JDAI-CV/CoTNet">https://github.com/JDAI-CV/CoTNet</a></p>
<p><del>(代码没太看懂)</del> </p>
<p>本文认为，Transformer的自注意力仅在空域进行信息交互，依赖于输入自身相关性通过独立的方式学习所得，而忽略了近邻间丰富的上下文信息。<br><img src="https://img-blog.csdnimg.cn/465450ac77ed4f428f0de8ed76433800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b696d5f224344f83962e5c40d04e3617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5e75b9874b104317941e17de7cf1580c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/dc99ecd85c1e4754a83ef17e0ca33a26.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/8f222dc07041466b9fe0422a4ac4560b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2021-MaskFormer-Per-Pixel-Classification-is-Not-All-You-Need-for-Semantic-Segmentation【已开源】【分割】"><a href="#2021-MaskFormer-Per-Pixel-Classification-is-Not-All-You-Need-for-Semantic-Segmentation【已开源】【分割】" class="headerlink" title="2021- MaskFormer- Per-Pixel Classification is Not All You Need for Semantic Segmentation【已开源】【分割】"></a>2021- MaskFormer- Per-Pixel Classification is Not All You Need for Semantic Segmentation【已开源】【分割】</h2><p>【代码】： <a href="https://github.com/facebookresearch/MaskFormer">https://github.com/facebookresearch/MaskFormer</a><br><img src="https://img-blog.csdnimg.cn/f9754efef4104ee39fa533b6364228b7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d1a1fbfc70f94991afc34ac291fdc415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ff26fa3e30c440cf9ab4b0488a1ac1fe.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>MaskFormer的结构如上图所示，主要可以分为三个部分：</p>
<p>1）pixel-level module：用来提取每个像素embedding（灰色背景部分）</p>
<p>2）transformer module：用来计算N个segment的embedding（绿色背景部分）</p>
<p>3）segmentation module：根据上面的per-pixel embedding和per-segment embedding，生成预测结果。（蓝色背景部分）</p>
<p><strong>3.3.1. Pixel-level module</strong><br>在Pixel-level module中，首先用backbone对图片的H和W进行压缩，通道维度进行提升，提取视觉特征，这一部分和正常CNN提取特征类似。然后用一个pixel Decoder去将长宽重新转换为H和W。</p>
<p><strong>3.3.2. Transformer module</strong><br>Transformer module的结构就是标准的Transformer Decoder的结构，根据视觉特征和N个可学习的query来计算输出。</p>
<p><strong>3.3.3. Segmentation module</strong><br>Segmentation  module就是一个FC的结构，后面接上softmax激活函数。它的输出就是segment的概率估计，因此根据这个概率估计和GroundTruth做分类的损失。</p>
<p>对于mask的预测，作者将per-segment embedding通过一个两层的MLP转换成了N个mask embedding。接着，作者将mask embedding和per-pixel embedding进行了点乘，后面接上了sigmoid激活函数，来获得最后mask的预测结果。 </p>
<p><strong>本文亮点总结</strong></p>
<blockquote>
<p>1.作者在这篇论文中提出，其实mask分类是非常通用的，完全可以用mask分类来统一语义分类和实例分类的范式。因此，作者提出了MaskFormer，能够将现有的per-pixel分类的模型转换为mask分类的模型。</p>
<p>2.作者通过实验表明，一个简单的mask分类模型可以优于SOTA的per-pixel分类模型，特别是在存在大量类别的情况下。本文提出的MaskFormer在全景分割任务上也保持着很强的竞争力，最重要的不需要改变模型架构、损失或训练过程。</p>
</blockquote>
<h2 id="2021-SegFormer-Simple-and-Efficient-Design-for-Semantic-Segmentation-with-Transformers【已开源】【分割】"><a href="#2021-SegFormer-Simple-and-Efficient-Design-for-Semantic-Segmentation-with-Transformers【已开源】【分割】" class="headerlink" title="2021- SegFormer: Simple and Efficient Design for Semantic Segmentation with Transformers【已开源】【分割】"></a>2021- SegFormer: Simple and Efficient Design for Semantic Segmentation with Transformers【已开源】【分割】</h2><p>【代码】：<a href="https://github.com/NVlabs/SegFormer">https://github.com/NVlabs/SegFormer</a></p>
<p><img src="https://img-blog.csdnimg.cn/a217a973e0bf4c459c70fc22faab7541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>感觉没啥创新</p>
<ul>
<li>去掉固定形状的位置编码，用3*3卷积作为位置信息补充</li>
<li>编码器部分每层都输出特征图传入后面（层次化）</li>
<li>Overlapped Patch Merging，卷积核大于步长实现</li>
<li>Effiicient Self-Attention，由于计算复杂度和序列长度的平方成正比，所以通过reshape和Linear操作将长度由N=H*W变为N/R，具体操作如下<br><img src="https://img-blog.csdnimg.cn/6cc02129eecc4c339b2690adb7994633.png" alt="在这里插入图片描述"></li>
</ul>
<h2 id="2021-VOLO-Vision-Outlooker-for-Visual-Recognition【已开源】【分类】"><a href="#2021-VOLO-Vision-Outlooker-for-Visual-Recognition【已开源】【分类】" class="headerlink" title="2021-VOLO: Vision Outlooker for Visual Recognition【已开源】【分类】"></a>2021-VOLO: Vision Outlooker for Visual Recognition【已开源】【分类】</h2><p>【代码】：<a href="https://github.com/sail-sg/volo">https://github.com/sail-sg/volo</a></p>
<p>和token-to-token同一个团队</p>
<h2 id="2021-HaloNet：Scaling-Local-Self-Attention-for-Parameter-Efficient-Visual-Backbones【未开源】【分类】"><a href="#2021-HaloNet：Scaling-Local-Self-Attention-for-Parameter-Efficient-Visual-Backbones【未开源】【分类】" class="headerlink" title="2021- HaloNet：Scaling Local Self-Attention for Parameter Efficient Visual Backbones【未开源】【分类】"></a>2021- HaloNet：Scaling Local Self-Attention for Parameter Efficient Visual Backbones【未开源】【分类】</h2><p>【代码】： </p>
<h2 id="2021-CoAtNet-Marrying-Convolution-and-Attention-for-All-Data-Sizes【未开源】【分类】"><a href="#2021-CoAtNet-Marrying-Convolution-and-Attention-for-All-Data-Sizes【未开源】【分类】" class="headerlink" title="2021- CoAtNet: Marrying Convolution and Attention for All Data Sizes【未开源】【分类】"></a>2021- CoAtNet: Marrying Convolution and Attention for All Data Sizes【未开源】【分类】</h2><p>【代码】：<br>【参考博客】：<a href="https://mp.weixin.qq.com/s?__biz=MzI5MDUyMDIxNA==&amp;mid=2247561682&amp;idx=1&amp;sn=5562d0dde1abbc49312864f16c927e81&amp;chksm=ec1d1c2bdb6a953dd763b7e1b8b89fdc5b11cd7ff327880e71ef43b80df88d9c232c113421dd&amp;scene=178&amp;cur_album_id=1685054606675902466#rd">极客平台</a><br>CNN具有归纳偏置（inductive bias），较强的泛化能力，Transformer具有更强的学习能力。本篇文章试图将CNN和Transformer进行结合，引入CNN那种对局部信息的感知，通过这种inductive bias，使得模型在CV任务上具有更好的性能。<br>Depthwise Convolution 的表达式可以写成：<br><img src="https://img-blog.csdnimg.cn/ce4bc96a699b49c1bf8d35f96d369c4b.png" alt="在这里插入图片描述"><br>式中xi和yi表示第 i个位置的输入和输出，Li表示第 i个位置的邻域，比如3×3的邻域。<br>Self-Attention的计算主要分为三步，第一步是将query和每个key进行相似度计算得到权重，常用的相似度函数有点积，拼接，感知机等；第二步是使用一个softmax函数对这些权重进行归一化；最后将权重和相应的键值value进行加权求和得到最后的结果。<br><img src="https://img-blog.csdnimg.cn/4cb414bc0de541d7b35b0e4bd422dab4.png" alt="在这里插入图片描述"></p>
<p>Self-attention 的表达式可以写成：<br><img src="https://img-blog.csdnimg.cn/2f6e6434c70840c796c164d58bb49fea.png" alt="在这里插入图片描述"><br>他们各自的特点是：<br><img src="https://img-blog.csdnimg.cn/12a29b0ce9e84e0d8c85489ede1271c5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了将Conv和Self-Attention的优点结合，可以将静态的全局全局和和自适应注意力矩阵相加，因此就可以表示呈下面的公式：<br><img src="https://img-blog.csdnimg.cn/d09db6f3ae5140669ce32b2612eca4a2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>本文采用yiPre，先softmax，再求和</p>
<h2 id="2021-CSWin-Transformer-A-General-Vision-Transformer-Backbone-with-Cross-Shaped-Windows【已开源】【分类】"><a href="#2021-CSWin-Transformer-A-General-Vision-Transformer-Backbone-with-Cross-Shaped-Windows【已开源】【分类】" class="headerlink" title="2021- CSWin Transformer: A General Vision Transformer Backbone with Cross-Shaped Windows【已开源】【分类】"></a>2021- CSWin Transformer: A General Vision Transformer Backbone with Cross-Shaped Windows【已开源】【分类】</h2><p>【代码】： <a href="https://github.com/microsoft/CSWin-Transformer">https://github.com/microsoft/CSWin-Transformer</a><br><img src="https://img-blog.csdnimg.cn/23d7b2d8572b4edfa3fec3cf07270614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b68592f6eccc4f788dc8aa743cddb84e.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5e67c008a146498fbbeb92b7ab9a644a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为什么每个stage的sw是不一样的？</p>
<p>因为SWin每个stage之后都进行了降采样，所以越到后面的stage，特征的H和W会越来越小。作者在前面的stage中采用了较小的sw，后面的stage中采用较大的sw。</p>
<p>个人觉得这么做主要有两方面的原因：</p>
<p>1）第一，前期H和W较大，如果sw也比较大，那就会导致计算量很大，极端情况下，sw=H或者sw=W，那就相当于直接进行了全局的SA，导致计算量爆炸。因此作者在前期H、W较大的时候，用较小的sw来限制计算量；后期等H、W比较小的时候，在用比较大的sw来扩大感受野。</p>
<p>2）第二，前面的Stage是用来获取局部的attention（这里指宽度较小的十字），后面的stage用获取全局的attention。（但是个人感觉如果这么做的话，就和作者提的Motivation有点冲突了，因为其他ViT结构的由局部慢慢变成全局注意力，如果前面的stage用较小的sw，那么前期也只能捕获局部注意力（十字形的局部），所以就跟其他结构一样是从局部到全局的一个过程。</p>
<h2 id="2021-Transformer-in-Transformer【已开源】【分类】"><a href="#2021-Transformer-in-Transformer【已开源】【分类】" class="headerlink" title="2021- Transformer in Transformer【已开源】【分类】"></a>2021- Transformer in Transformer【已开源】【分类】</h2><p>【代码】：<a href="https://github.com/huawei-noah/CV-Backbones/tree/master/tnt_pytorch">https://github.com/huawei-noah/CV-Backbones/tree/master/tnt_pytorch</a><br><img src="https://img-blog.csdnimg.cn/a7feabd26c1f47ee84d517d0159dcab6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2021-PVT-Pyramid-Vision-Transformer-A-Versatile-Backbone-for-Dense-Prediction-without-Convolutions【已开源】【分类】"><a href="#2021-PVT-Pyramid-Vision-Transformer-A-Versatile-Backbone-for-Dense-Prediction-without-Convolutions【已开源】【分类】" class="headerlink" title="2021-PVT-Pyramid Vision Transformer: A Versatile Backbone for Dense Prediction without Convolutions【已开源】【分类】"></a>2021-PVT-Pyramid Vision Transformer: A Versatile Backbone for Dense Prediction without Convolutions【已开源】【分类】</h2><p>【代码】：<a href="https://github.com/whai362/PVT">https://github.com/whai362/PVT</a><br><img src="https://img-blog.csdnimg.cn/e18d2477184b4c308d1d075bdfd08172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/9d6e2dbcc8804876ad887425e6399500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2021-Twins-Revisiting-the-Design-of-Spatial-Attention-in-Vision-Transformers【已开源】【分类】【美团】"><a href="#2021-Twins-Revisiting-the-Design-of-Spatial-Attention-in-Vision-Transformers【已开源】【分类】【美团】" class="headerlink" title="2021-Twins: Revisiting the Design of Spatial Attention in Vision Transformers【已开源】【分类】【美团】"></a>2021-Twins: Revisiting the Design of Spatial Attention in Vision Transformers【已开源】【分类】【美团】</h2><p>【代码】：<a href="https://github.com/Meituan-AutoML/Twins">https://github.com/Meituan-AutoML/Twins</a><br>CPVT认为，绝对位置编码在处理不同大小的输入时会遇到困难，且绝对位置编码也会打破平移不变性。本文证明，Swin优于PVT的主要原因就是这点，如果使用适当的位置编码，PVT实际上可以实现比Swin Transformer更好的性能<br>提出了两个Transformer结构（第一个完全没创新，就是这个拼那个，第二个主要就是局部注意力做完之后接一个全局）</p>
<blockquote>
<ol>
<li>Twins-PCPVT：用CPVT的条件位置编码CPE来替换PVT中的绝对位置编码。</li>
<li>Twins-SVT：交替局部和全局注意力</li>
</ol>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/3f364b5eca5c44d0a7b658215e15dc26.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/74a79d2bc1b64b74989e382b4f4708d0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2021-DPT-Deformable-Patch-based-Transformer-for-Visual-Recognition【已开源】【分类】"><a href="#2021-DPT-Deformable-Patch-based-Transformer-for-Visual-Recognition【已开源】【分类】" class="headerlink" title="2021-DPT: Deformable Patch-based Transformer for Visual Recognition【已开源】【分类】"></a>2021-DPT: Deformable Patch-based Transformer for Visual Recognition【已开源】【分类】</h2><p>【代码】： <a href="https://github.com/CASIA-IVA-Lab/DPT">https://github.com/CASIA-IVA-Lab/DPT</a></p>
<p>代码缺失部分模块<br><img src="https://img-blog.csdnimg.cn/bac411d679ad4b7dacbcbeace21d3383.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASm95Y2Vfbw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="2021-Focal-Self-attention-for-Local-Global-Interactions-in-Vision-Transformers【未开源】【分类】"><a href="#2021-Focal-Self-attention-for-Local-Global-Interactions-in-Vision-Transformers【未开源】【分类】" class="headerlink" title="2021-Focal Self-attention for Local-Global Interactions in Vision Transformers【未开源】【分类】"></a>2021-Focal Self-attention for Local-Global Interactions in Vision Transformers【未开源】【分类】</h2><p>【代码】： </p>
<h2 id="2021-Mobile-Former-Bridging-MobileNet-and-Transformer【未开源】【分类】"><a href="#2021-Mobile-Former-Bridging-MobileNet-and-Transformer【未开源】【分类】" class="headerlink" title="2021-Mobile-Former: Bridging MobileNet and Transformer【未开源】【分类】"></a>2021-Mobile-Former: Bridging MobileNet and Transformer【未开源】【分类】</h2><p>【代码】： </p>
<p>轻量级CNN和Transformer桥接，结构挺复杂新颖</p>
<h2 id="2021-MCTrans：【即将开源】【2021MICCAI】"><a href="#2021-MCTrans：【即将开源】【2021MICCAI】" class="headerlink" title="2021-MCTrans：【即将开源】【2021MICCAI】"></a>2021-MCTrans：【即将开源】【2021MICCAI】</h2><p>【代码】： </p>
<p>MCTrans 可以很容易地插入到类似 UNet 的网络中</p>
<h2 id="2021-TransClaw-U-Net-Claw-U-Net-with-Transformers-for-Medical-Image-Segmentation【未开源】【分割】"><a href="#2021-TransClaw-U-Net-Claw-U-Net-with-Transformers-for-Medical-Image-Segmentation【未开源】【分割】" class="headerlink" title="2021-TransClaw U-Net: Claw U-Net with Transformers for Medical Image Segmentation【未开源】【分割】"></a>2021-TransClaw U-Net: Claw U-Net with Transformers for Medical Image Segmentation【未开源】【分割】</h2><p>将CNN和Transformer结合起来，表现SOTA！性能优于TransUNet、AttUNet等网络，作者单位：华东师范大学, 上海交通大学等<br>由于卷积操作的局限性，往往无法准确获取长期的空间特征。因此，我们提出了一种 TransClaw U-Net 网络结构，它在编码部分结合了卷积操作和Transformer操作。卷积部分用于提取浅层空间特征，以利于上采样后图像分辨率的恢复。 Transformer 部分用于对patch 进行编码，使用self-attention 机制获取序列之间的全局信息。解码部分保留了底部上采样结构，以获得更好的细节分割性能。 Synapse Multi-organ Segmentation Datasets 上的实验结果表明。</p>
<p><img src="https://img-blog.csdnimg.cn/20210716221414746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2021-TransAttUnet-Multi-level-Attention-guided-U-Net-with-Transformer-for-Medical-Image-Segmentation【未开源】【分割】"><a href="#2021-TransAttUnet-Multi-level-Attention-guided-U-Net-with-Transformer-for-Medical-Image-Segmentation【未开源】【分割】" class="headerlink" title="2021-TransAttUnet: Multi-level Attention-guided U-Net with Transformer for Medical Image Segmentation【未开源】【分割】"></a>2021-TransAttUnet: Multi-level Attention-guided U-Net with Transformer for Medical Image Segmentation【未开源】【分割】</h2><p>基于Transformer的多级注意力引导U-Net<br>表现SOTA！性能优于MCTrans、FANet和ResUNet++等网络，作者单位：哈工大(深圳), 香港中文大学<br>随着深度编码器-解码器架构和大规模注释医学数据集的发展，自动医学图像分割的发展取得了很大进展。由于卷积层的堆叠和连续的采样操作，现有的标准模型不可避免地会遇到特征表示的信息衰退问题，无法完全建模全局上下文特征依赖关系。为了克服上述挑战，本文提出了一种新的基于 Transformer 的医学图像语义分割框架 TransAttUnet，其中联合设计了多级引导注意和多尺度跳过连接，以有效增强传统 U 形的功能性和灵活性。建筑学。受 Transformer 的启发，一个具有 Transformer Self Attention (TSA) 和 Global Spatial Attention (GSA) 的新型自感知注意力 (SAA) 模块被整合到 TransAttUnet 中，以有效地学习编码器特征之间的非局部交互。特别是，我们还在解码器块之间建立了额外的多尺度跳跃连接，以聚合不同的语义尺度上采样特征。通过这种方式，增强了多尺度上下文信息的表示能力以生成判别特征。受益于这些互补的组件，所提出的 TransAttUnet 可以有效缓解信息衰退问题导致的精细细节丢失，提高医学图像分析的诊断灵敏度和分割质量。对不同成像的多个医学图像分割数据集的大量实验表明，我们的方法始终优于最先进的基线。<br><img src="https://img-blog.csdnimg.cn/20210716221547822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2021-FFVT-Feature-Fusion-Vision-Transformer-for-Fine-Grained-Visual-Categorization【未开源】【分类】"><a href="#2021-FFVT-Feature-Fusion-Vision-Transformer-for-Fine-Grained-Visual-Categorization【未开源】【分类】" class="headerlink" title="2021-FFVT-Feature Fusion Vision Transformer for Fine-Grained Visual Categorization【未开源】【分类】"></a>2021-FFVT-Feature Fusion Vision Transformer for Fine-Grained Visual Categorization【未开源】【分类】</h2><p>用于细粒度视觉分类的特征融合视觉Transformer<br>据作者称，这是第一个探索视觉Transformer在小规模和大规模细粒度视觉分类上性能的研究，并提出一种基于纯Transformer的框架特征融合ViT：FFVT，表现SOTA！性能优于TransFG、NTS-Net等网络，单位：格里菲斯大学<br>处理细粒度视觉分类 (FGVC) 的核心是学习细微但有辨别力的特征。以前的大多数工作都是通过显式选择判别部分或通过基于 CNN 的方法集成注意力机制来实现的。 然而，这些方法增加了计算复杂度，并使模型由包含最多对象的区域主导。最近，视觉转换器（ViT）在一般图像识别任务上实现了 SOTA 性能。自注意力机制将所有patch的信息聚合并加权到分类令牌，使其非常适合 FGVC。尽管如此，深度的分类token更关注全局信息，缺乏 FGVC 必不可少的局部和低级特征。在这项工作中，我们提出了一种新颖的纯基于Transformer的框架特征融合视觉Transformer（FFVT），我们聚合来自每个Transformer层的重要标记来补偿局部、低级和中级信息。我们设计了一个称为相互注意权重选择 (MAWS) 的新型token选择模块，以有效和高效地引导网络在不引入额外参数的情况下选择判别性token。我们在三个基准测试中验证了 FFVT 的有效性，其中 FFVT 实现了最先进的性能。<br><img src="https://img-blog.csdnimg.cn/20210716221802692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Feature fusion is exploited before the last transformer layer to aggregate the important local, low-level and middle level information from previous layers. This is implemented by replacing the inputs (exclude classification token) of the last transformer layer with the tokens selected by the MAWS Module.<br><strong>Feature Fusion Module</strong><br>MSA在深层更倾向于关注全局信息，所以提出特征融合模块来补偿局部信息。<br>具体操作：将最后一层transformer层的输入替换为前面每层Transformer经过MAWS筛选后的tokens。In this way, the class token in the last transformer layer fully interacts with the low-level, middle level and high-level features from the previous layers, enriching the local information and feature representation capability.<br><img src="https://img-blog.csdnimg.cn/20210716222815133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Our feature fusion strategy is motivated by [12]【Transfg: A transformer architecture for fine-grained recognition】 which only selects the tokens from the penultimate transformer layer, yet our method directly aggregates important information from each layer.</p>
<p><strong>Mutual AttentionWeight Selection Module 相互注意权重选择模块</strong><br>提出一个token selection方法，通过直接利用多头自注意力模块生成的attention scores<br>来选择。<br><img src="https://img-blog.csdnimg.cn/20210716223332481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中，aij是token i 和token j关于token i上下文中的注意得分<br>一个简单的策略是选择和分类token有更高注意得分的token，因为分类token包含丰富的类别信息。如果用这种方法的话，可以直接对a0进行排序，然后选择值最大的token。这种方法称为single attention weight selection（SAWS）。但这种方法可能会引入噪声信息因为被选择的token可能聚合了更多来自噪声patches的信息。<br>拿3个patch块的attention得分矩阵来举例：<br><img src="https://img-blog.csdnimg.cn/2021071622395455.png" alt="在这里插入图片描述"><br>Token three is selected as it has the biggest value in the attention score vector for classification token. However, token three aggregates much information from token one (the<br> maximum attention score in a3) thus may introduce noises assuming token one is a noisy token。<br>为了解决这种问题，提出一种mutual attention weight selection module，需要被选择的token和分类token在分类token的上下文和它自己的上下文中都相似。<br>将attention得分矩阵的第一列表示为b0，b0即为分类token和其他token在其他token上下文中的attention得分向量。<br>最终，mutual attention weight（MAW）mai为：<br><img src="https://img-blog.csdnimg.cn/2021071622564865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="2021-TransFG-A-Transformer-Architecture-for-Fine-grained-Recognition【已开源】【分类】"><a href="#2021-TransFG-A-Transformer-Architecture-for-Fine-grained-Recognition【已开源】【分类】" class="headerlink" title="2021-TransFG: A Transformer Architecture for Fine-grained Recognition【已开源】【分类】"></a>2021-TransFG: A Transformer Architecture for Fine-grained Recognition【已开源】【分类】</h2><p>细粒度视觉分类中最重要的问题之一是准确定位解释相似子类之间细微差异的判别区域</p>
<h2 id="2021-LG-Transformer-Local-to-Global-Self-Attention-in-Vision-Transformer【未开源】【分类】"><a href="#2021-LG-Transformer-Local-to-Global-Self-Attention-in-Vision-Transformer【未开源】【分类】" class="headerlink" title="2021-LG-Transformer-Local-to-Global Self-Attention in Vision Transformer【未开源】【分类】"></a>2021-LG-Transformer-Local-to-Global Self-Attention in Vision Transformer【未开源】【分类】</h2><p>Transformer的缺点很明显：计算复杂度和输入的特征大小呈平方的关系。因此直接对整张图片进行Self-Attention是不现实的，所以，最近的一些工作（比如Swin-Transformer[1]）采用了像CNN一样的分层结构，每层施加注意力的范围只在local window上，逐渐扩大Self-Attention的感知范围。<br>作者提出，这样的方式存在一定的缺点，因为在前面几个stage中没有对global的特征进行感知，因此，作者就提出了一种多分支的Transformer设计结构，使得Transformer在每个stage中都进同时进行全局和局部的信息感知。通过引入多分支结构，使得模型在分类任务和语义分割任务上都取得了一定的性能提升。<br>希望在前面的stage中也能加入全局的信息感知，所以作者引入了多分支结构，有的分支用来捕获全局的注意力（先降采样），有的分支用来捕获局部注意力，相当于是在Transformer中采用了一个类似Inception的结构<br><img src="https://img-blog.csdnimg.cn/img_convert/60d270a3a12e2f2b6cbd564deca1c198.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/4f61c338e01cb3b8b4340bea7b6ab6da.png" alt="在这里插入图片描述"></p>
<h2 id="2021-CCTrans-Simplifying-and-Improving-Crowd-Counting-with-Transformer"><a href="#2021-CCTrans-Simplifying-and-Improving-Crowd-Counting-with-Transformer" class="headerlink" title="2021-CCTrans: Simplifying and Improving Crowd Counting with Transformer"></a>2021-CCTrans: Simplifying and Improving Crowd Counting with Transformer</h2><ul>
<li><p>单位：哈尔滨工业大学（深圳）、美团</p>
</li>
<li><p>Arxiv: <a href="https://arxiv.org/abs/2109.14483">https://arxiv.org/abs/2109.14483</a></p>
</li>
<li><p>Github: 即将开源</p>
</li>
</ul>
<p>人群计数</p>
<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;</p>
<h2 id="2021-Tokens-to-Token-ViT：Training-Vision-Transformers-from-Scratch-on-ImageNet【已开源】【分类】"><a href="#2021-Tokens-to-Token-ViT：Training-Vision-Transformers-from-Scratch-on-ImageNet【已开源】【分类】" class="headerlink" title="2021-Tokens-to-Token ViT：Training Vision Transformers from Scratch on ImageNet【已开源】【分类】"></a>2021-Tokens-to-Token ViT：Training Vision Transformers from Scratch on ImageNet【已开源】【分类】</h2><p>预训练图片大小： 384<br>【代码】： <a href="https://github.com/yitu-opensource/T2T-ViT">https://github.com/yitu-opensource/T2T-ViT</a><br>本文认为中等大小数据集上，Transformer性能低于CNN的原因有两点：</p>
<ol>
<li>ViT处理图片的方式不够好，无法建模一张图片的局部信息</li>
<li>ViT的自注意力极值的Backbone不如CNN设计的更好</li>
</ol>
<p>采用类似CNN中卷积划窗的方式，将相邻的tokens局部聚合起来，有助于建模局部特征。另外还设计了一种deep narrow（个人理解是 深+窄 的网络结构）结构，减少了运算量，并获得性能上的提升。<br>​​​​​​​​<br><img src="https://img-blog.csdnimg.cn/20210709094733464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>本文先分析了Resnet50，Vision Transformer，T2T Transformer的特征可视化。其中绿框标注的是浅层特征，如边缘，线条。红框标注全白全黑的是一些零值或过大值，对最终预测没有贡献</p>
<p>我们先从熟悉的CNN看起，在比较浅的层中，网络学习到的更多是结构信息，比如对这只小狗边缘的刻画。随着层数加深，通道数变深，特征也越来越抽象</p>
<p>再来看ViT，他每层都能很好的建模全局信息，即使是很深的层当中，也没有所谓非常抽象的东西。但它对结构信息捕捉的很少，（个人认为是没有类似CNN卷积核划窗的操作，导致对局部信息捕捉不够？）ViT的表现不尽相同，浅层特征和中层特征的冗余度很高，很多channels的可视化结果十分相似，缺乏边、角、纹理等信息）</p>
<p>Token to Token 结构</p>
<p><img src="https://img-blog.csdnimg.cn/20210709094746875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Vision Transformer是将二维图片展平成一维向量（也叫token），然后送入到Transoformer结构里。而T2T为了捕捉局部信息，它将所有的token通过reshape操作，恢复成二维，然后利用一个unfold一个划窗操作，属于一个窗口的tokens，会连接成一个更长的token，然后送入到Transformer中。</p>
<p>这样会逐渐减少token的数量，但随之而来token的长度会增加很多（因为多个tokens连接在一个token），因此后续模型也降低了维度数目，以平衡计算量。</p>
<p>经过比较作者得到两个结论：</p>
<ol>
<li>使用Deep-narrow架构，并减少embedding dimension更适合视觉Transformer，可以增加特征的丰富程度，同时减少计算量</li>
<li>SE模块的channel attention结构也可以提升ViT性能，但结果不如1</li>
</ol>
<p><strong>关于Unfold操作</strong><br>Unfold操作其实就是卷积中用到的img2col方法，将一个卷积窗口的向量，重排成一个列向量。<br><img src="https://img-blog.csdnimg.cn/5133320a402a47739bcac1b65537f58f.png" alt="在这里插入图片描述"></p>
<p>下面是一段测试代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np_input = np.array([[[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">                       [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]],</span><br><span class="line">                     [[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">                      [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">                      [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>]],</span><br><span class="line">                     [[<span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>],</span><br><span class="line">                      [<span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>],</span><br><span class="line">                      [<span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>]],</span><br><span class="line">                     [[<span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">                      [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>],</span><br><span class="line">                      [<span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>]]]]).astype(np.float32)</span><br><span class="line"></span><br><span class="line">torch_input = torch.Tensor(np_input)</span><br><span class="line"></span><br><span class="line">unfold = torch.nn.Unfold(kernel_size=<span class="number">2</span>, padding=<span class="number">0</span>, stride=<span class="number">1</span>)</span><br><span class="line">unfolded = unfold(torch_input)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(unfolded)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出为</span></span><br><span class="line">tensor([[[ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>],</span><br><span class="line">         [ <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>],</span><br><span class="line">         [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>],</span><br><span class="line">         [ <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">8.</span>,  <span class="number">9.</span>],</span><br><span class="line">         [<span class="number">10.</span>, <span class="number">11.</span>, <span class="number">13.</span>, <span class="number">14.</span>],</span><br><span class="line">         [<span class="number">11.</span>, <span class="number">12.</span>, <span class="number">14.</span>, <span class="number">15.</span>],</span><br><span class="line">         [<span class="number">13.</span>, <span class="number">14.</span>, <span class="number">16.</span>, <span class="number">17.</span>],</span><br><span class="line">         [<span class="number">14.</span>, <span class="number">15.</span>, <span class="number">17.</span>, <span class="number">18.</span>],</span><br><span class="line">         [<span class="number">19.</span>, <span class="number">20.</span>, <span class="number">22.</span>, <span class="number">23.</span>],</span><br><span class="line">         [<span class="number">20.</span>, <span class="number">21.</span>, <span class="number">23.</span>, <span class="number">24.</span>],</span><br><span class="line">         [<span class="number">22.</span>, <span class="number">23.</span>, <span class="number">25.</span>, <span class="number">26.</span>],</span><br><span class="line">         [<span class="number">23.</span>, <span class="number">24.</span>, <span class="number">26.</span>, <span class="number">27.</span>],</span><br><span class="line">         [<span class="number">28.</span>, <span class="number">29.</span>, <span class="number">31.</span>, <span class="number">32.</span>],</span><br><span class="line">         [<span class="number">29.</span>, <span class="number">30.</span>, <span class="number">32.</span>, <span class="number">33.</span>],</span><br><span class="line">         [<span class="number">31.</span>, <span class="number">32.</span>, <span class="number">34.</span>, <span class="number">35.</span>],</span><br><span class="line">         [<span class="number">32.</span>, <span class="number">33.</span>, <span class="number">35.</span>, <span class="number">36.</span>]]])</span><br></pre></td></tr></table></figure>
<p>这是对应的示意图<br><img src="https://img-blog.csdnimg.cn/20210709094809380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29oX09PTw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>T2T ViT</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T2T_ViT</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, img_size=<span class="number">224</span>, tokens_type=<span class="string">&#x27;performer&#x27;</span>, in_chans=<span class="number">3</span>, num_classes=<span class="number">1000</span>, embed_dim=<span class="number">768</span>, depth=<span class="number">12</span>,</span></span><br><span class="line"><span class="params">                 num_heads=<span class="number">12</span>, mlp_ratio=<span class="number">4.</span>, qkv_bias=<span class="literal">False</span>, qk_scale=<span class="literal">None</span>, drop_rate=<span class="number">0.</span>, attn_drop_rate=<span class="number">0.</span>,</span></span><br><span class="line"><span class="params">                 drop_path_rate=<span class="number">0.</span>, norm_layer=nn.LayerNorm</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.num_classes = num_classes</span><br><span class="line">        self.num_features = self.embed_dim = embed_dim  <span class="comment"># num_features for consistency with other models</span></span><br><span class="line"></span><br><span class="line">        self.tokens_to_token = T2T_module(</span><br><span class="line">            img_size=img_size, tokens_type=tokens_type, in_chans=in_chans, embed_dim=embed_dim)</span><br><span class="line">        num_patches = self.tokens_to_token.num_patches</span><br><span class="line"></span><br><span class="line">        self.cls_token = nn.Parameter(torch.zeros(<span class="number">1</span>, <span class="number">1</span>, embed_dim))</span><br><span class="line">        self.pos_embed = nn.Parameter(data=get_sinusoid_encoding(n_position=num_patches + <span class="number">1</span>, d_hid=embed_dim),</span><br><span class="line">                                      requires_grad=<span class="literal">False</span>)</span><br><span class="line">        self.pos_drop = nn.Dropout(p=drop_rate)</span><br><span class="line"></span><br><span class="line">        dpr = [x.item() <span class="keyword">for</span> x <span class="keyword">in</span> torch.linspace(<span class="number">0</span>, drop_path_rate, depth)]  <span class="comment"># stochastic depth decay rule</span></span><br><span class="line">        self.blocks = nn.ModuleList([</span><br><span class="line">            Block(</span><br><span class="line">                dim=embed_dim, num_heads=num_heads, mlp_ratio=mlp_ratio, qkv_bias=qkv_bias, qk_scale=qk_scale,</span><br><span class="line">                drop=drop_rate, attn_drop=attn_drop_rate, drop_path=dpr[i], norm_layer=norm_layer)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(depth)])</span><br><span class="line">        self.norm = norm_layer(embed_dim)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Classifier head</span></span><br><span class="line">        self.head = nn.Linear(embed_dim, num_classes) <span class="keyword">if</span> num_classes &gt; <span class="number">0</span> <span class="keyword">else</span> nn.Identity()</span><br><span class="line"></span><br><span class="line">        trunc_normal_(self.cls_token, std=<span class="number">.02</span>)</span><br><span class="line">        self.apply(self._init_weights)</span><br><span class="line"></span><br><span class="line">    ...忽略一些其他的方法</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward_features</span>(<span class="params">self, x</span>):</span><br><span class="line">        B = x.shape[<span class="number">0</span>]</span><br><span class="line">        x = self.tokens_to_token(x)</span><br><span class="line"></span><br><span class="line">        cls_tokens = self.cls_token.expand(B, -<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">        x = torch.cat((cls_tokens, x), dim=<span class="number">1</span>)</span><br><span class="line">        x = x + self.pos_embed</span><br><span class="line">        x = self.pos_drop(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> blk <span class="keyword">in</span> self.blocks:</span><br><span class="line">            x = blk(x)</span><br><span class="line"></span><br><span class="line">        x = self.norm(x)</span><br><span class="line">        <span class="keyword">return</span> x[:, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.forward_features(x)</span><br><span class="line">        x = self.head(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>整个架构是将输入数据通过T2Tmodule，然后设立一个分类的token(cls_tokens)，将其concat到x中，并加入position embedding（这里是用一个可学习参数作为位置编码）。处理好后，输入到一个个叠起来的Transformer Block，最后取第一个token（也就是cls_tokens)，输入到分类层，得到最终结果。</p>
]]></content>
      <categories>
        <category>研究生期间</category>
      </categories>
      <tags>
        <tag>调研</tag>
        <tag>深度学习</tag>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>基于深度学习的颅内出血分割系统设计与实现</title>
    <url>/2022/07/16/013-%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%A2%85%E5%86%85%E5%87%BA%E8%A1%80%E5%88%86%E5%89%B2%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><strong>写在前面</strong><br>后续还加了存储图片功能，但是太久远了都不记得具体代码是哪份了，等之后有机会再补全</p>
<blockquote>
<p>将Attention U-Net网络应用到颅内出血区域分割中，基于Tensorflow后端的Keras框架搭建Attention U-Net网络模型并训练，选取合适的阈值进行全局阈值后处理。<br>利用Python 和Tkinter设计开发基于Attention U-Net的分割系统，用户可通过本系统任意选择测试集的图像，加载训练好的模型来预测和显示分割结果，还可选择U-Net、MultiResUnet、SegNet网络进行分割结果对比。</p>
</blockquote>
<h2 id="常见的Python-GUI"><a href="#常见的Python-GUI" class="headerlink" title="常见的Python GUI"></a>常见的Python GUI</h2><p>图形用户界面（GUI），也被称作图形用户接口。它指的是给用户提供图形交互的操作界面，用户可以通过输入设备和界面进行交流，表述自己的需求。GUI集美观性、实用性于一体。相较于命令行界面而言，不需要代码指令造成视觉疲劳，普通用户更易接受。</p>
<h3 id="Tkinter"><a href="#Tkinter" class="headerlink" title="Tkinter"></a>Tkinter</h3><p>Tkinter是Python内置的GUI标准库，历史最悠久，具有跨平台的特性，可在Linux、Windows等系统上执行。使用Tkinter可以快速地创建GUI应用程序进行窗口视窗设计，提供简洁美观的计算机操作用户界面，非常适合小型应用开发，它还提供多种图形接口，如标签（Label）、按钮（Button）、画布（Canvas）等。<br>安装Python就已经同时安装此模块，使用前只需写入以下语句导入此模块即可。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br></pre></td></tr></table></figure></p>
<h3 id="PyQt"><a href="#PyQt" class="headerlink" title="PyQt"></a>PyQt</h3><p>Qt是C++语言下广泛应用的程序设计库。PyQt来源于Qt C++ GUI类库，是其Python绑定版本，拥有丰富的类上千个函数和方法，在常见操作系统上都可运行。由于Qt应用范围广，PyQt功能丰富，开发文档也较为齐全，是出名的的Tkinter替代品。不过PyQt语法较为复杂，且需要单独安装。</p>
<h3 id="wxPython"><a href="#wxPython" class="headerlink" title="wxPython"></a>wxPython</h3><p>wxPython同PyQt非常相似，也是来源于C++ GUI类库，是Python语言对GUI工具集wxWidgets的绑定，跨平台能力极为优秀。使用wxPython前必须安装扩展模块，可供学习的文档较少，开发过程中遇到问题难以解决。 </p>
<h2 id="系统设计与实现"><a href="#系统设计与实现" class="headerlink" title="系统设计与实现"></a>系统设计与实现</h2><h3 id="系统界面设计和功能实现"><a href="#系统界面设计和功能实现" class="headerlink" title="系统界面设计和功能实现"></a>系统界面设计和功能实现</h3><p>系统由介绍界面、基于Attention U-Net的颅内出血区域分割界面、和多种分割网络对比界面组成，这三个界面是基于tkinter.ttk模块的NoteBook控件实现选项卡子窗口切换，每个子窗口通过add方法添加进NoteBook实例化对象。详细系统构成见图示意。<br><img src="/2022/07/16/013-%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%A2%85%E5%86%85%E5%87%BA%E8%A1%80%E5%88%86%E5%89%B2%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.png" class title="This is an test image"></p>
<h3 id="系统介绍界面"><a href="#系统介绍界面" class="headerlink" title="系统介绍界面"></a>系统介绍界面</h3><p>系统介绍界面详细介绍了系统的基础功能和界面内容，在短时间内让初次使用的用户对系统有一定了解，掌握系统操作方法。<br><img src="/2022/07/16/013-%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%A2%85%E5%86%85%E5%87%BA%E8%A1%80%E5%88%86%E5%89%B2%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D.png" class title="This is an test image"></p>
<h3 id="基于Attention-U-Net的颅内出血区域分割界面"><a href="#基于Attention-U-Net的颅内出血区域分割界面" class="headerlink" title="基于Attention U-Net的颅内出血区域分割界面"></a>基于Attention U-Net的颅内出血区域分割界面</h3><p>基于Attention U-Net的图像分割界面主要由展示、评价指标和操作三个模块组成，每个模块都是由标签框架（LabelFrame）构成，边缘设置边框，界面简洁明了。</p>
<img src="/2022/07/16/013-%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%A2%85%E5%86%85%E5%87%BA%E8%A1%80%E5%88%86%E5%89%B2%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/Att%E5%88%86%E5%89%B2%E5%89%8D.png" class title="This is an test image">
<p>操作模块的四个按钮具体实现如下。</p>
<ul>
<li>“打开图片”按钮绑定open_files()方法，通过调用filedialog包中的askopenfilenames函数实现多文件读取，令filetypes为“*.png”指定读取文件类型。由于原图像尺寸过大，读取图片后采用了Image.resize函数对图像执行高质量裁剪。</li>
<li>“分割出血区域”按钮绑定att_seg()方法，通过model.predict预测分割结果。</li>
<li>“查看真值图”按钮绑定get_GT()方法，将第一步读取到的路径中的image替换为label，从新路径读取图片并显示真值图。此方法的前提是待分割图像和其真值图放在同一个文件夹的image、label两个文件夹下。</li>
<li>“查看评价指标”按钮绑定get_dice()方法。评价指标模块的表格形式主要由tkinter.ttk模块的Treeview控件组成，右侧绑定了滚动条控件用于显示更多界面信息。方法内部调用judge(y_true,y_pred)方法计算评价指标，并用insert()方法插入表格内容。</li>
</ul>
<p>展示栏由三列无边框的标签框架内含数个Label标签构成，在读取到图片信息后会通过config和标签绑定从而显示图片。<br>用户按照操作栏的四个按钮依次执行，系统会显示选择的图片和其分割图、真值图，还可查看评价指标判断每张图片的分割精确度。</p>
<img src="/2022/07/16/013-%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%A2%85%E5%86%85%E5%87%BA%E8%A1%80%E5%88%86%E5%89%B2%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/att%E5%88%86%E5%89%B2%E7%BB%93%E6%9E%9C%E7%95%8C%E9%9D%A2.png" class title="This is an test image">
<p>“分割出血区域”按钮调用了模型预测函数，在配置差的计算机中运行速度极为缓慢，甚至会卡顿，这里采用从threading模块创建多线程的方法将函数打包进线程，虽然显示图片速度依旧缓慢，但能有效避免卡死。为了让等待的过程产生趣味性，系统在需要较长时间等待操作时，产生置顶窗口并调用tkinter.ttk模块的Progressbar标签产生进度条，模仿加载过程。</p>
<img src="/2022/07/16/013-%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%A2%85%E5%86%85%E5%87%BA%E8%A1%80%E5%88%86%E5%89%B2%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E8%BF%9B%E5%BA%A6%E6%9D%A1.png" class title="This is an test image">
<p>需要注意的是，目前系统只支持同时分割不多于10张图片，当选择打开的图片数量过多时，会出现警告，并只保留选择的前十张图片进行后续操作。警告信息是从tkinter导入弹窗库后，调用messagebox.showwarning得到的。</p>
<img src="/2022/07/16/013-%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%A2%85%E5%86%85%E5%87%BA%E8%A1%80%E5%88%86%E5%89%B2%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E8%AD%A6%E5%91%8A.png" class title="This is an test image">
<h3 id="多种分割网络对比界面"><a href="#多种分割网络对比界面" class="headerlink" title="多种分割网络对比界面"></a>多种分割网络对比界面</h3><p>多种分割网络对比界面由原图、真值图、分割图、评价指标、操作五个模块构成。<br><img src="/2022/07/16/013-%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%A2%85%E5%86%85%E5%87%BA%E8%A1%80%E5%88%86%E5%89%B2%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%A4%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%89%B2%E5%8E%9F%E5%A7%8B.png" class title="This is an test image"></p>
<img src="/2022/07/16/013-%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%A2%85%E5%86%85%E5%87%BA%E8%A1%80%E5%88%86%E5%89%B2%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%A4%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%89%B2%E7%BB%93%E6%9E%9C.png" class title="This is an test image">
<h3 id="生成可执行文件"><a href="#生成可执行文件" class="headerlink" title="生成可执行文件"></a>生成可执行文件</h3><p>配置程序运行环境是一个复杂又易出错的过程，为了让本系统轻松运行在其他计算机上，选择Pyinstaller工具将程序打包成可执行文件，让系统具备可移植性。<br>Pyinstaller是Python的一个用于打包生成可执行文件的工具，不随Python默认安装，可使用pip命令安装。安装完成后命令行提示符窗口切换到系统程序所在路径下，执行pyinstaller system.py segnet_model.py，就可以生成带有控制台窗口的exe文件。</p>
]]></content>
      <categories>
        <category>研究生期间</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>深度学习</tag>
        <tag>Keras</tag>
        <tag>Tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title>算法岗知识点</title>
    <url>/2022/08/11/014-%E7%AE%97%E6%B3%95%E5%B2%97%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="代价函数-损失函数"><a href="#代价函数-损失函数" class="headerlink" title="代价函数/损失函数"></a>代价函数/损失函数</h3><p><a href="https://mp.weixin.qq.com/s/lv-3QJuCjxH8pW94FrzTUQ">深度学习常用损失函数总览：基本形式、原理、特点</a></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>Offer</tag>
      </tags>
  </entry>
</search>
