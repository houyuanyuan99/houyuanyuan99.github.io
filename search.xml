<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>位运算</title>
    <url>/2022/07/02/001-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<!-- ![这里输入图片描述](/力扣.png) -->
<!-- ![](/img/leetcode.png) -->
<!-- <img src="/2022/07/02/001-%E4%BD%8D%E8%BF%90%E7%AE%97/leetcode.png" class="" title="This is an test image"> -->
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191.位1的个数"></a>191.位1的个数</h3><p>题目链接：<a href="https://leetcode.cn/problems/number-of-1-bits/">https://leetcode.cn/problems/number-of-1-bits/</a></p>
<p>若 $n = 2^x$  且 x为自然数（即 n 为 2 的幂），则恒有 $ n \&amp;(n - 1) == 0 $ ，这是因为：<br>$n$ 二进制最高位为 1，其余所有位为0；<br>$n−1$ 二进制最高位为 0，其余所有位为 1；<br><!-- ![](/1.png) --><br><img src="/2022/07/02/001-%E4%BD%8D%E8%BF%90%E7%AE%97/1.png" class title="This is an test image"></p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="and运算-amp"><a href="#and运算-amp" class="headerlink" title="and运算&amp;"></a>and运算&amp;</h3><p>  and运算通常用于二进制的取位操作，例如一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数。<br>相同位的两个数字都为1，则为1；若有一个不为1，则为0。</p>
<h3 id="or运算"><a href="#or运算" class="headerlink" title="or运算 |"></a>or运算 |</h3><p>or运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。<br>相同位只要一个为1即为1。</p>
<h3 id="xor运算"><a href="#xor运算" class="headerlink" title="xor运算 ^"></a>xor运算 ^</h3><p>异或的符号是^。按位异或运算, 对等长二进制模式按位或二进制数的每一位执行逻辑按位异或操作. 操作的结果是如果某位不同则该位为1, 否则该位为0.<br>xor运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即(a xor b) xor b = a。xor运算可以用于简单的加密。<br>相同位不同则为1，相同则为0。</p>
<h3 id="not运算"><a href="#not运算" class="headerlink" title="not运算 ~"></a>not运算 ~</h3><p>not运算的定义是把内存中的0和1全部取反。使用not运算时要格外小心，你需要注意整数类型有没有符号。如果not的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用00到$FFFF依次表示的。</p>
<h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h3><p>a &lt;&lt; b就表示把a转为二进制后左移b位（在后面添b个0）。例如100的二进制为1100100，而110010000转成十进制是400，那么100 shl 2 = 400。可以看出，a shl b的值实际上就是a乘以2的b次方，因为在二进制数后添一个0就相当于该数乘以2。<br>通常认为a &lt;&lt; 1比a * 2更快，因为前者是更底层一些的操作。因此程序中乘以2的操作请尽量用左移一位来代替。<br>定义一些常量可能会用到&lt;&lt;运算。你可以方便地用1 &lt;&lt; 16 - 1来表示65535。很多算法和数据结构要求数据规模必须是2的幂，此时可以用&lt;&lt;来定义Max_N等常量。</p>
<h3 id="带符号右移-gt-gt"><a href="#带符号右移-gt-gt" class="headerlink" title="带符号右移&gt;&gt;"></a>带符号右移&gt;&gt;</h3><p>和&lt;&lt;相似，a &gt;&gt; b表示二进制右移b位（去掉末b位,最左边用0填充），相当于a除以2的b次方（取整）。和上面一样的例子，那么400 &gt;&gt;2 = 100。我们也经常用&gt;&gt;1来代替div 2，比如二分查找、堆的插入操作等等。想办法用&gt;&gt;代替除法运算可以使程序效率大大提高。最大公约数的二进制算法用除以2操作来代替慢得出奇的mod运算，效率可以提高60%。</p>
<h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 整数集合set位运算</span><br><span class="line"># 整数集合做标志时，比如回溯时的visited标志数组</span><br><span class="line">vstd 访问 i ：vstd | (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">vstd 离开 i ：vstd &amp; ~(<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">vstd 不包含 i : <span class="keyword">not</span> vstd &amp; (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">并集 ：A | B</span><br><span class="line">交集 ：A &amp; B</span><br><span class="line">全集 ：(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line">补集 ：((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) ^ A</span><br><span class="line">子集 ：(A &amp; B) == B</span><br><span class="line">判断是否是 <span class="number">2</span> 的幂 ：A &amp; (A - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">最低位的 <span class="number">1</span> 变为 <span class="number">0</span> ：n &amp;= (n - <span class="number">1</span>)</span><br><span class="line">最低位的 <span class="number">1</span>：A &amp; (-A)，最低位的 <span class="number">1</span> 一般记为 <span class="built_in">lowbit</span>(A)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>数据集汇总和介绍</title>
    <url>/2022/07/07/003-%E6%95%B0%E6%8D%AE%E9%9B%86%E6%B1%87%E6%80%BB%E5%92%8C%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/mou_it/article/details/82225505">https://blog.csdn.net/mou_it/article/details/82225505</a></p>
<p><a href="https://www.jianshu.com/p/16b2e32d9edf">https://www.jianshu.com/p/16b2e32d9edf</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>数据集</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题记录</title>
    <url>/2022/07/05/002-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="第三百场周赛补题-蔚来"><a href="#第三百场周赛补题-蔚来" class="headerlink" title="第三百场周赛补题-蔚来"></a>第三百场周赛补题-蔚来</h2><h3 id="2325-解密消息（简单）"><a href="#2325-解密消息（简单）" class="headerlink" title="2325. 解密消息（简单）"></a>2325. 解密消息（简单）</h3><p>给你字符串 key 和 message ，分别表示一个加密密钥和一段加密消息。解密 message 的步骤如下：</p>
<p>使用 key 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 顺序 。<br>将替换表与普通英文字母表对齐，形成对照表。<br>按照对照表 替换 message 中的每个字母。<br>空格 ‘ ‘ 保持不变。<br>例如，key = “happy boy”（实际的加密密钥会包含字母表中每个字母 至少一次），据此，可以得到部分对照表（’h’ -&gt; ‘a’、’a’ -&gt; ‘b’、’p’ -&gt; ‘c’、’y’ -&gt; ‘d’、’b’ -&gt; ‘e’、’o’ -&gt; ‘f’）。</p>
<p>题目链接：<a href="https://leetcode.cn/problems/decode-the-message">https://leetcode.cn/problems/decode-the-message</a></p>
<p><strong>示例</strong></p>
<img src="/2022/07/05/002-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2325.jpg" class title="This is an test image">
<blockquote>
<p>输入：key = “the quick brown fox jumps over the lazy dog”, message = “vkbs bs t suepuv”<br>输出：”this is a secret”<br>解释：对照表如上图所示。<br>提取 “the quick brown fox jumps over the lazy dog” 中每个字母的首次出现可以得到替换表。</p>
</blockquote>
<p>对map之类的容器生疏了，比赛的时候写的太复杂了，这里复习一遍用法加强印象<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeMessage</span><span class="params">(string key, string message)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>,<span class="type">char</span>&gt; mp;</span><br><span class="line">        mp[<span class="string">&#x27; &#x27;</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;key.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp[key[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                mp[key[i]] = <span class="string">&#x27;a&#x27;</span> + cnt;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;message.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            message[i] = mp[message[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="2326-螺旋矩阵-IV（中等）"><a href="#2326-螺旋矩阵-IV（中等）" class="headerlink" title="2326. 螺旋矩阵 IV（中等）"></a>2326. 螺旋矩阵 IV（中等）</h3><p>给你两个整数：m 和 n ，表示矩阵的维数。</p>
<p>另给你一个整数链表的头节点 head 。</p>
<p>请你生成一个大小为 m x n 的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵 左上角 开始、顺时针 按 螺旋 顺序填充。如果还存在剩余的空格，则用 -1 填充。</p>
<p>返回生成的矩阵。</p>
<p>题目链接：<a href="https://leetcode.cn/problems/spiral-matrix-iv">https://leetcode.cn/problems/spiral-matrix-iv</a></p>
<p><strong>示例</strong><br><img src="/2022/07/05/002-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2326.jpg" class title="This is an test image"></p>
<blockquote>
<p>输入：m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]<br>输出：[[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]<br>解释：上图展示了链表中的整数在矩阵中是如何排布的。<br>注意，矩阵中剩下的空格用 -1 填充。</p>
</blockquote>
<p><strong>思路</strong><br>在矩阵内四个方向依次轮转，当越界或者当前的格子已经填过数时，即转换方向</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrix</span>(<span class="type">int</span> m, <span class="type">int</span> n, ListNode* head) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;m;x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;n;++y)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[x][y] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>][<span class="number">0</span>] = head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j+dx[cur]&lt;<span class="number">0</span>||j+dx[cur]&gt;=n||i+dy[cur]&lt;<span class="number">0</span>||i+dy[cur]&gt;=m||ans[i+dy[cur]][j+dx[cur]]!=<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = (cur+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i+=dy[cur];j+=dx[cur];</span><br><span class="line">            ans[i][j] = head-&gt;val;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2327-知道秘密的人数（中等）"><a href="#2327-知道秘密的人数（中等）" class="headerlink" title="2327. 知道秘密的人数（中等）"></a>2327. 知道秘密的人数（中等）</h3><p>在第 1 天，有一个人发现了一个秘密。</p>
<p>给你一个整数 delay ，表示每个人会在发现秘密后的 delay 天之后，每天 给一个新的人 分享 秘密。同时给你一个整数 forget ，表示每个人在发现秘密 forget 天之后会 忘记 这个秘密。一个人 不能 在忘记秘密那一天及之后的日子里分享秘密。</p>
<p>给你一个整数 n ，请你返回在第 n 天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对 10e + 7 取余 后返回。</p>
<p>题目链接：<a href="https://leetcode.cn/problems/number-of-people-aware-of-a-secret">https://leetcode.cn/problems/number-of-people-aware-of-a-secret</a></p>
<p><strong>示例</strong></p>
<blockquote>
<p>输入：n = 6, delay = 2, forget = 4<br>输出：5<br>解释：<br>第 1 天：假设第一个人叫 A 。（一个人知道秘密）<br>第 2 天：A 是唯一一个知道秘密的人。（一个人知道秘密）<br>第 3 天：A 把秘密分享给 B 。（两个人知道秘密）<br>第 4 天：A 把秘密分享给一个新的人 C 。（三个人知道秘密）<br>第 5 天：A 忘记了秘密，B 把秘密分享给一个新的人 D 。（三个人知道秘密）<br>第 6 天：B 把秘密分享给 E，C 把秘密分享给 F 。（五个人知道秘密）</p>
</blockquote>
<p><strong>思路</strong><br>递推，动态规划</p>
<p><strong>解法1</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peopleAwareOfSecret</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> delay, <span class="type">int</span> forget)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">2</span>)); <span class="comment">//考虑用long long</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//dp[i][j]表示在第i天知道秘密天数为第j天的人</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=delay;j&lt;forget;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>] = (dp[i<span class="number">-1</span>][j]+dp[i][<span class="number">1</span>])%mod;</span><br><span class="line">                <span class="comment">//第i天新知道消息的人消息来源来自前一天知道消息delay天~forget天的人，求和</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=forget;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="comment">//第i天知道消息j天（j&gt;=2）的人是第i-1天知道消息j-1天的人</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=forget;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = (ans+dp[n][i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><strong>解法2</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peopleAwareOfSecret</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> delay, <span class="type">int</span> forget)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>)</span></span>;<span class="comment">//表示第i天新增的知道消息的人数</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i-forget+<span class="number">1</span>;j&lt;=i-delay;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] += dp[j];</span><br><span class="line">                    dp[i] = dp[i]%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=n-forget+<span class="number">1</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = (ans+dp[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="2328-网格图中递增路径的数目（困难）"><a href="#2328-网格图中递增路径的数目（困难）" class="headerlink" title="2328. 网格图中递增路径的数目（困难）"></a>2328. 网格图中递增路径的数目（困难）</h3><p>给你一个 m x n 的整数网格图 grid ，你可以从一个格子移动到 4 个方向相邻的任意一个格子。</p>
<p>请你返回在网格图中从 任意 格子出发，达到 任意 格子，且路径中的数字是 严格递增 的路径数目。由于答案可能会很大，请将结果对 10e9 + 7 取余 后返回。</p>
<p>如果两条路径中访问过的格子不是完全相同的，那么它们视为两条不同的路径</p>
<p>题目链接：<a href="https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid">https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid</a></p>
<p><strong>示例</strong><br><img src="https://assets.leetcode.com/uploads/2022/05/10/griddrawio-4.png" alt></p>
<blockquote>
<p>输入：grid = [[1,1],[3,4]]<br>输出：8<br>解释：严格递增路径包括：</p>
<pre><code>- 长度为 1 的路径：[1]，[1]，[3]，[4] 。
- 长度为 2 的路径：[1 -&gt; 3]，[1 -&gt; 4]，[3 -&gt; 4] 。
- 长度为 3 的路径：[1 -&gt; 3 -&gt; 4] 。
路径数目为 4 + 3 + 1 = 8 。
</code></pre></blockquote>
<p><strong>思路</strong><br>记忆化搜索<br>记录 f(i, j) 表示以 (i, j) 为结尾的不同路径有几条。计算 f(i,j) 时，检查 (i, j) 上下左右四个格子，若相邻格子里的数比当前格子里的数小，则可以转移给 f(i, j)。当然最后别忘了计算从 (i, j)开始，然后直接在 (i, j) 结束的路径，也就是 f(i, j) 还要再加 1。</p>
<p>用记忆化搜索即可在 $ O(nm) $ 的复杂度内完成。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; f;</span><br><span class="line">    <span class="comment">// long long f[1010][1010];</span></span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        f[x][y] = <span class="number">1</span>; <span class="comment">//长度为1的路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i) <span class="comment">//检查相邻格子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tx = x+dx[i];<span class="type">int</span> ty = y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(tx&lt;n&amp;&amp;tx&gt;=<span class="number">0</span>&amp;&amp;ty&lt;m&amp;&amp;ty&gt;=<span class="number">0</span>&amp;&amp;grid[x][y]&gt;grid[tx][ty])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!f[tx][ty]) <span class="built_in">dfs</span>(tx,ty,grid);</span><br><span class="line">                f[x][y] = (f[x][y]+f[tx][ty])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPaths</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n = grid.<span class="built_in">size</span>();</span><br><span class="line">        m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        f.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(m));</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(f[i][j]==<span class="number">0</span>) <span class="built_in">dfs</span>(i,j,grid);</span><br><span class="line">                ans = (ans+f[i][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
</search>
